---
title: Preparation
subtitle: Data are downloaded, preprocessed, and design information extracted
jupyter: mkernel
order: 11
---


```{matlab}
% select subject
sub = 'subj1';
```


{{< include ../_setup_figure.qmd >}}

```{matlab}
%| echo: false
% start from scratch
[~] = rmdir(sub, 's');
```


## Download and unpack data

The data for the subject are downloaded from [PyMVPA](http://dev.pymvpa.org/datadb/haxby2001.html) as a `.tar.gz` archive, and the archive is unpacked.

```{matlab}
fn = [sub '-2010.01.14.tar.gz'];
url = ['http://data.pymvpa.org/datasets/haxby2001/' fn];
urlwrite(url, fn);
untar(fn)
delete(fn)
```

The included NIfTI images are individually gzip-compressed and need to be uncompressed.

```{matlab}
files = dir(fullfile(sub, '*.nii.gz'));
for i = 1 : numel(files)
    fprintf('uncompressing %s\n', files(i).name)
    gunzip(fullfile(sub, files(i).name))
    delete(fullfile(sub, files(i).name))
end
```

The mask images are not documented in detail. Based on the filenames and the in-mask volume, we assume the following correspondence between regions listed in Table 1 of the paper and mask image files:

`mask4_vt.nii`
:   'all ventral temporal object-selective cortex'

`mask8b_face_vt.nii`
:   'region maximally responsive to faces'

`mask8b_house_vt.nii`
:   'region maximally responsive to houses'

::: callout-caution
TODO: do they need to be aligned to the anatomical or the mean BOLD image?
:::

```{matlab}
fnBOLD = fullfile(sub, 'bold.nii');
regions = {fullfile(sub, 'mask4_vt.nii'), ...
           fullfile(sub, 'mask8b_face_vt.nii'), ...
           fullfile(sub, 'mask8b_house_vt.nii')};
```


## Obtain experimental design information

The BOLD data are contained in a single 4-dimensional NIfTI file.

```{matlab}
N = nifti(fnBOLD);
size(N.dat)
diag(N.mat(1:3, 1:3))'
TR = N.timing.tspace
```

This file contains a timeseries of 1452 scans at at repetition time of 2.5 s, each of which has 40 × 64 × 64 voxels of size 3.5 × 3.75 × 3.75 mm.

From Footnote 18 of the [paper](index.html#ref-haxby2001):

> Stimuli were gray-scale images of faces, houses, cats, bottles, scissors, shoes, chairs, and nonsense patterns. … Twelve time series were obtained in each subject. Each time series began and ended with 12 s of rest and contained eight stimulus blocks of 24-s duration, one for each category, separated by 12-s intervals of rest. Stimuli were presented for 500 ms with an interstimulus interval of 1500 ms.

Each of the 12 sessions therefore had a duration of (12 + 24) × 8 + 12 = 300 s, corresponding to 120 TRs (121 scans).

Information about the onsets and durations of stimuli in this subject are contained in a file `labels.txt`.

```{matlab}
labels = readtable(fullfile(sub, 'labels.txt'), 'Delimiter', ' ');
head(labels)
```

```{matlab}
tail(labels)
```

It has 1452 rows, corresponding to the scans of the BOLD data. The format is not documented, but it appears that the column `labels` contains the experimental condition (stimulus type), and the column `chunk` distinguishes the 12 sessions by an index from 0 to 11, each with 121 rows. In the order of the paper, the condition names are

```{matlab}
conditions = ["face", "house", "cat", "bottle", ...
    "scissors", "shoe", "chair", "scrambledpix"];
```

plus `"rest"` for the rest intervals. 

Stimulus blocks comprise 9 rows with rest intervals of 5 or 6 rows, which does not exactly correspond to the description above because the stimulus presentation length is incompatible with the TR. We therefore use these data only to extract the condition index for each block, but recreate more precise stimulus timing information.

```{matlab}
nSessions = 12;
nConds = numel(conditions);
onsets = cell(nSessions, nConds);
durations = cell(nSessions, nConds);
% for each session
for si = 1 : nSessions
    % extract condition for each block (from its middle)
    cond = labels.labels(labels.chunks == si - 1);
    [~, condInd] = ismember(cond, conditions);
    condInd = condInd(round((24 :(12 + 24): 300) / TR) + 1);
    assert(isequal(sort(condInd).', 1:8))
    % for each condition
    for ci = 1 : nConds
        % assemble stimulus onset and duration information in s
        blockInd = find(condInd == ci);
        blockStart = (blockInd - 1) * (12 + 24) + 12;
        onsets{si, ci} = blockStart + (0 : 11) * (0.5 + 1.5);
        durations{si, ci} = 0.5 * ones(1, 12);
    end
end
nVolsPerSession = height(labels) / nSessions;
```

Visualization of stimulus onsets in each session:

```{matlab}
fig = figure;
fig.Position(3:4) = [750, 400];
colors = ["#000000", "#ff9b00", "#a6ee00", "#00eea6", ...
    "#009bff", "#a600ff", "#ff00a6", "#aaaaaa"];
for ci = 1 : nConds
    ons = [];
    ses = [];
    for si = 1 : nSessions
        ons = [ons, onsets{si, ci}];
        ses = [ses, si * ones(size(onsets{si, ci}))];
    end
    plot(ons, ses, '.', 'Color', colors(ci))
    hold all
end
xlim([-1 , nVolsPerSession] * TR)
ylim([0.5, nSessions + 0.5])
set(gca, 'YTick', 1 : nSessions)
set(gca, 'YDir', 'reverse')
ylabel('session')
xlabel('time / s')
legend(conditions, Location="eastoutside")
```


## Realign BOLD data

```{matlab}
fnrBOLD = fullfile(sub, 'rbold.nii');
matlabbatch = {};
for si = 1 : nSessions
    vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);
    vn = arrayfun(@(i) sprintf('%s,%d', fnBOLD, i), ...
        vi, 'UniformOutput', false);
    matlabbatch{1}.spm.spatial.realign.estwrite.data{si} = vn';
end
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.quality = 0.9;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.sep = 4;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.fwhm = 5;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.rtm = 1;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.interp = 2;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.wrap = [0 0 0];
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.weight = '';
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.which = [2 1];
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.interp = 4;
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.wrap = [0 0 0];
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.mask = 1;
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.prefix = 'r';
set(spm_figure('GetWin', 'Graphics'), 'Visible', 'off')
spm_jobman('run', matlabbatch)
```


## Save information

```{matlab}
fnInfo = fullfile(sub, 'info.mat');
save(fnInfo, 'regions', 'TR', 'nSessions', 'nVolsPerSession', ...
    'conditions', 'nConds', 'onsets', 'durations', 'colors')
```

<!-- Copyright © 2023 Carsten Allefeld
SPDX-License-Identifier: GPL-3.0-or-later -->
