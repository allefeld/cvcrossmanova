---
title: Cross-validated MANOVA
subtitle: Pattern distinctness is computed in regions of interest and via searchlight
jupyter: mkernel
order: 13
---


{{< include ../_setup_figure.qmd >}}


```{matlab}
% select subject
sub = 'subj1';
% load information
load(fullfile(sub, 'info.mat'))
% directory with estimated model
modelDir = fullfile(sub, 'model');
```


## Define contrasts

We are looking at two effects:

1) the 'effect of stimulus', i.e. quantifying how much patterns associated with the eight different stimuli differ from each other and
2) the 'effect of category within inanimate object', i.e. quantifying how much patterns associated with 'bottle', 'scissors', 'shoe', and 'chair' differ from each other.

The corresponding contrasts consist of 7 and 3 subcontrasts (columns), respectively, each of which targets the difference between two conditions.

```{matlab}
C_stimulus = ...
    [  1  0  0  0  0  0  0      % face
      -1  1  0  0  0  0  0      % house
       0 -1  1  0  0  0  0      % cat
       0  0 -1  1  0  0  0      % bottle
       0  0  0 -1  1  0  0      % scissors
       0  0  0  0 -1  1  0      % shoe
       0  0  0  0  0 -1  1      % chair
       0  0  0  0  0  0 -1 ];   % scrambledpix
C_object_category = ...
    [  0  0  0                  % face
       0  0  0                  % house
       0  0  0                  % cat
       1  0  0                  % bottle
      -1  1  0                  % scissors
       0 -1  1                  % shoe
       0  0 -1                  % chair
       0  0  0 ];               % scrambledpix
```

Note that though the subcontrasts only combine neighboring conditions, the null hypothesis defined by all of them together says that there is no difference in the patterns associated with any of the involved conditions. For example for `C_object_category`, the three subcontrasts state

1) pattern of 'bottle' = pattern of 'scissors',
2) pattern of 'scissors' = pattern of 'shoe', and
3) pattern of 'shoe' = pattern of 'chair'.

If all three statements hold, that also implies that there is no difference e.g. between the pattern of 'bottle' and the pattern of 'chair'. The result of cross-validated MANOVA, pattern distinctness *D*, estimates how much of the multivariate variance deviates from the null hypothesis encoded in a contrast.


## Define analyses

An analysis is represented by an object of [class `Analysis`](/reference.qmd#analysis). It comprises two contrasts, for 'training' (A) and 'validation' (B), but for cross-validated MANOVA the two are identical. It also defines a validation scheme which for each fold specifies which sessions are used for 'training' and 'validation'. Here we use standard [leave-one-session-out](/reference.qmd#analysis.leaveonesessionout) cross-validation, but more complex schemes can be defined.

```{matlab}
analysis_stimulus = Analysis.leaveOneSessionOut(nSessions, C_stimulus)
```

```{matlab}
analysis_object_category = Analysis.leaveOneSessionOut( ...
    nSessions, C_object_category)
```

By default no permutations are performed, but that can be [requested explicitly](/reference.qmd#analysis.addpermutations). We here limit the number of permutations to 100, though a larger number is recommended if available.

```{matlab}
rng(1837146515, 'twister')
analysis_object_category.addPermutations(100)
```

If the requested number of permutations (parameter `maxPerms`, default 1000) is larger than or equal to the number of possible permutations, all possible permutations are performed; if not, a subset is chosen randomly. For reproducibility of analyses it is advisable to [explicitly initialize](https://uk.mathworks.com/help/matlab/math/generate-random-numbers-that-are-repeatable.html) Matlab's random number generator with `rng`. The arguments used here were originally chosen based on the fields `Seed` and `Type` from `s = rng('shuffle')`.

As seen above, evaluating an `Analysis` object prints a [brief summary](/reference.qmd#analysis.disp). It can also be visualized using the method [`show`](/reference.qmd#analysis.show):

```{matlab}
analysis_object_category.show()
```

Below we need a cell array which contains all `Analysis` objects.

```{matlab}
analyses = {analysis_stimulus, analysis_object_category};
```


## Run analyses on regions of interest

To perform region-of-interest analyses, use the [function `cvCrossManovaRegion`](/reference.qmd#cvcrossmanovaregion). It

-   loads the data via the `SPM.mat` file in `modelDir`, restricted to the voxels in the regions specified via `regions`,
-   creates an object of [class `CvCrossManova`](/reference.qmd#cvcrossmanova) which includes the data, design matrices, and the specified `analyses`,
-   and then runs the analyses on the regions and returns the results.

The output first reports on loading the data and then displays the created `CvCrossManova` object, including information on the contained analyses.

```{matlab}
[Ds, ps] = cvCrossManovaRegion(modelDir, regions, analyses);
```

The result `ps` is an array with the number of voxels in each region.

```{matlab}
ps
```

The result `Ds` is a cell array with one row for each analysis, and one column for each region. For the first analysis each cell contains a scalar, which is the estimated value of *D*.

```{matlab}
Ds(1, :)
```

```{matlab}
%|echo : false
% regression test
value = [Ds{1, :}];
expected = '[5.3228309400800411, 0.30012393047769736, 1.6930630901451187]';
assert(all(value == eval(expected)), ...
    'result does not match expected %s', expected)
clear expected
```

For the second analysis each cell contains an array with 100 elements, corresponding to the 100 permutations we requested. The first value is the actual estimated value of *D*, the others are permutation values.

```{matlab}
Ds(2, :)
```

```{matlab}
%|echo: false
% regression test
value = sum(cat(1, Ds{2, :}), 2)';
expected = '[1.2852740961380142, -0.018025507532779275, 0.58444270402859833]';
assert(all(value == eval(expected)), ...
    'result does not match expected %s', expected)
clear expected
```

Based on this, we can calculate a *p*-value for the null hypothesis 'no effect of category within inanimate object', in each region.

```{matlab}
for i = 1 : numel(regions)
    D = Ds{2, i};
    pval = mean(D >= D(1));
    fprintf('%-25s  D = %g, p = %g\n', regions{i}, D(1), pval)
end
```

The null hypothesis can be rejected in all three regions.


## Run analyses with searchlight

To perform searchlight analyses, use the [function `cvCrossManovaSearchlight`](/reference.qmd#cvcrossmanovasearchlight). It

-   loads the data via the `SPM.mat` file in `modelDir`,
-   creates an object of [class `CvCrossManova`](/reference.qmd#cvcrossmanova) which includes the data, design matrices, and the specified `analyses`,
-   and then runs the analyses on the voxels included in each searchlight.

The output first reports on loading the data and then displays the created `CvCrossManova` object, including information on the contained analyses.

```{matlab}
slRadius = 3;
cvCrossManovaSearchlight(modelDir, slRadius, analyses)
```

Results are written to files in the model directory. `ccmsParameters.mat` is a record of the analysis parameters and `VPSL.nii` is an image file where each voxel contains the number of voxels of the searchlight centered on it.

```{matlab}
dir(modelDir)
```

Files with names of the form `spmD_A####_P####.nii` are images of pattern distinctness, i.e each voxel contains the estimated value of *D* from the voxels of the searchlight centered on it. The digits `####` after `A` identify the analysis, and the digits after `P` the permutation (if no permutations were requested, only `P0001` for the neutral permutation).

We visualize sagittal slices of `spmD_A0001_P0001.nii`, i.e. the actual pattern distinctness from the first analysis.

```{matlab}
% load data
D = spm_read_vols(spm_vol(fullfile(modelDir, 'spmD_A0001_P0001.nii')));
% plot data
fig = figure();
% color map: parula, but black for NaN
cm = parula();
cm(1, :) = 0;
colormap(cm)
% color limits: rounded to 0.01 away from data range
cl = [min(D(:)), max(D(:))];
cl = ceil(cl .* [-1, 1] * 100) .* [-1, 1] / 100;
% sagittal slices
fig.Position(3:4) = [750, 1200];
tiledlayout(8, 5, Padding="tight", TileSpacing="tight")
for i = 1 : size(D, 1)
    nexttile
    slice = squeeze(D(i, :, :)) .'; 
    imagesc(slice)
    clim(cl)
    axis off image xy
end
```


<!-- Copyright Â© 2023 Carsten Allefeld
SPDX-License-Identifier: GPL-3.0-or-later -->
