[
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "API Reference documentation",
    "section": "",
    "text": "cross-validated (Cross-) MANOVA on regions\n[Ds, ps] = cvCrossManovaRegion(modelDir, regions, analyses, lambda = 1e-8)\n\n\n\nmodelDir\ndirectory where the SPM.mat file referring to an estimated model is located\n\n\nregions\nregion mask(s), cell array of logical 3D volumes or filenames\n\n\nanalyses\ncell array of analysis specifications\n\n\nlambda\nregularization parameter (0–1)\n\n\nDs\npattern distinctness or pattern stability, cell array analyses × regions\n\n\nps\nnumber of voxels in the regions\n\n\n\nRegarding the parameters analyses and lambda and the contents of the cells of Ds, see also Analysis, CvCrossManova.CvCrossManova, CvCrossManova.runAnalyses.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#cvcrossmanovaregion",
    "href": "reference.html#cvcrossmanovaregion",
    "title": "API Reference documentation",
    "section": "",
    "text": "cross-validated (Cross-) MANOVA on regions\n[Ds, ps] = cvCrossManovaRegion(modelDir, regions, analyses, lambda = 1e-8)\n\n\n\nmodelDir\ndirectory where the SPM.mat file referring to an estimated model is located\n\n\nregions\nregion mask(s), cell array of logical 3D volumes or filenames\n\n\nanalyses\ncell array of analysis specifications\n\n\nlambda\nregularization parameter (0–1)\n\n\nDs\npattern distinctness or pattern stability, cell array analyses × regions\n\n\nps\nnumber of voxels in the regions\n\n\n\nRegarding the parameters analyses and lambda and the contents of the cells of Ds, see also Analysis, CvCrossManova.CvCrossManova, CvCrossManova.runAnalyses.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#cvcrossmanovasearchlight",
    "href": "reference.html#cvcrossmanovasearchlight",
    "title": "API Reference documentation",
    "section": "function cvCrossManovaSearchlight",
    "text": "function cvCrossManovaSearchlight\ncross-validated (Cross-) MANOVA on searchlight\ncvCrossManovaSearchlight(modelDir, slRadius, analyses, lambda = 1e-8)\n\n\n\nmodelDir\ndirectory where the SPM.mat file referring to an estimated model is located\n\n\nslRadius\nradius of the searchlight sphere in voxels\n\n\nanalyses\ncell array of analysis specifications\n\n\nlambda\nregularization parameter (0–1)\n\n\n\nResults are written to files the same directory:\n\n\n\nspmD_A####_P####.nii\nimages of pattern distinctness or pattern stability; analysis and permutation are identified by numbers\n\n\nVPSL.nii\nimage of the number of voxels for each searchlight\n\n\nccmsParameters.mat\nrecord of the analysis parameters\n\n\n\nNote that a voxel is included in a searchlight if its distance from the center voxel is smaller than or equal to the radius. Fractional values are possible and meaningful:\n\n\n\nslRadius\nmax. number of voxels\nslRadius\nmax. number of voxels\n\n\n\n\n0\n1\n3.17\n147\n\n\n1\n7\n3.32\n171\n\n\n1.42\n19\n3.47\n179\n\n\n1.74\n27\n3.61\n203\n\n\n2\n33\n3.75\n251\n\n\n2.24\n57\n4\n257\n\n\n2.45\n81\n4.13\n305\n\n\n2.83\n93\n4.25\n341\n\n\n3\n123\n4.36\n365\n\n\n\nThe searchlight procedure includes a checkpointing mechanism: Intermediate results are saved to a file ccmsCheckpoint….mat, where … stands for a 32-digit hexadecimal checksum. If an analysis is interrupted, running it again recovers partial results from the checkpoint file and continues from there.\nNote that this only works if the analysis parameters remain identical. In particular, if the analysis includes randomly selected permutations, make sure to initialize Matlab’s random number generator before the selection. It is recommended to run s = rng('shuffle') once, note the values of s.Seed and s.Type, and then to include rng(&lt;seed&gt;, &lt;type&gt;) in your analysis pipeline.\nRegarding the parameters slRadius, analyses and lambda see also slSize, Analysis, CvCrossManova.CvCrossManova.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#analysis",
    "href": "reference.html#analysis",
    "title": "API Reference documentation",
    "section": "class Analysis",
    "text": "class Analysis\nAn Analysis object encapsulates ‘training’ and ‘validation’ contrasts and sessions as well as permutations, which together specify a Cross-validated (Cross-) MANOVA analysis. It is combined with a ModeledData object and possibly other Analysis objects within a CvCrossManova object, which performs the actual analysis.\n\nproperties\n\n\n\nCA\n‘training’ contrast matrix, regressors × subcontrasts\n\n\nCB\n‘validation’ contrast matrix, regressors × subcontrasts\n\n\nsessionsA\n‘training’ sessions logical matrix, folds × sessions\n\n\nsessionsB\n‘validation’ sessions logical matrix, folds × sessions\n\n\nL\nnumber of folds\n\n\nm\nnumber of sessions\n\n\nperms\nsign permutations, permutations × sessions\n\n\n\n\n\nconstructor Analysis\ncreate Analysis object\nanalysis = Analysis(CA, CB, sessionsA, sessionsB)\nCA and CB are ‘training’ and ‘validation’ contrast matrices, respectively.\nsessionsA and sessionsB are logical matrices which indicate which sessions (columns) are used for ‘training’ and ‘validation’, respectively, in each fold (rows).\n\n\nstatic method leaveOneSessionOut\ncreate Analysis object for leave-one-session-out cross-validation\nanalysis = Analysis.leaveOneSessionOut(m, CA, CB)\nanalysis = Analysis.leaveOneSessionOut(m, C)\nm is the number of sessions. The object is created with ‘training’ sessions not(logical(eye(m))) and ‘validation’ sessions logical(eye(m)), the specification of standard leave-one-session-out cross-validation.\nCA and CB are ‘training’ and ‘validation’ contrast matrices, respectively. If only one contrast matrix C is specified, it is used for both.\n\n\nmethod addPermutations\nadd sign permutations of per-session parameter estimates\nanalysis.addPermutations(maxPerms = 1000)\nThis method adds information to analysis that sign permutations should be applied, so that different values of D for the different permutations are computed.\nFor m sessions there are formally 2m per-session sign permutations, but not all of them lead to different permutation values of D. The number of unique permutations depends on the ‘training’ and ‘validation’ sessions used in different folds (sessionsA, sessionsB). This method determines which permutations lead to different outcomes and makes sure only those unique permutations are included.\nThe permutations always include the neutral permutation, which does not modify the data and therefore results in the actual value of D. This neutral permutation is always permutation 1. A permutation test is implemented by comparing the neutral permutation value with all permutation values, and rejecting the null hypothesis at significance level α if it ranks within the upper α-quantile (see Ernst 2004).\n\n\n\n\n\n\nWarning\n\n\n\nSign permutations are used to test a per-subject null hypothesis of no effect in cross-validated MANOVA analyses. It does not make sense to apply them to Cross-MANOVAs.\n\n\nThe optional maxPerms specifies the maximum number of permutations. If the number of unique permutations exceeds maxPerms, a random subset is chosen for a Monte-Carlo permutation test (see Dwass 1957).\n\n\nmethod disp\ntextually display information about the object\nanalysis.disp()\nThis method overrides Matlab’s disp, so you can also use disp(analysis) or simply analysis without semicolon to get the same output.\n\n\nmethod show\ngraphically display information about the object\nfig = analysis.show()\nThis method creates a figure showing contrast matrices, session matrices, and if present permutations.\nfig is the handle of the created figure.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#modeleddata",
    "href": "reference.html#modeleddata",
    "title": "API Reference documentation",
    "section": "class ModeledData",
    "text": "class ModeledData\nA ModeledData object encapsulates data and design matrices for multiple sessions along with supplementary information. Upon creation, it estimates and stores GLM parameters and errors. Combined with one or more Analysis objects, it is the basis for analyses within a CvCrossManova object.\n\nproperties\n\n\n\nXs\ncell array of per-session data matrices, observations × independent variables\n\n\nYs\ncell array of per-session design matrices, observations × dependent variables\n\n\nfs\narray of per-session residual degrees of freedom\n\n\nm\nnumber of sessions\n\n\nns\narray of per-session numbers of observations\n\n\np\nnumber of dependent variables\n\n\nqs\narray of per-session numbers of independent variables\n\n\nnames\ncell array of per-session string arrays of names of independent variables\n\n\n\n\n\nconstructor ModeledData\ncreate ModeledData object\nmodeledData = ModeledData(Ys, Xs, fs = ..., names = ...)\nYs and Xs are cell arrays of per-session data and design matrices, respectively.\nThe optional fs is an array of per-session residual degrees of freedom. Their default values are size(Xs{k}, 1) - rank(Xs{k}), corresponding to the assumption that observations are uncorrelated. If observations have been only approximately decorrelated or have been filtered, correct values should be explicitly specified.\nThe optional names is a cell array of per-session string arrays of names of independent variables. Default names are identical in all sessions and of the form \"reg(#)\", where # is the index of the independent variable. If independent variables with the same index in different sessions have different meanings, correct names should be explicitly specified.\n\n\nstatic method fromSPM\ncreate ModeledData object from SPM data\n[modeledData, misc] = fromSPM(modelDir, regions = {}, wf = true)\nmodelDir is the directory where the SPM.mat file referring to an estimated model is located.\nThe optional regions is a cell array of logical 3D volumes or filenames specifying region masks. Without it, only the SPM brain mask is applied.\nThe optional wf specifies whether to apply whitening and high-pass filtering (set up in SPM) to data and design matrices.\n\n\n\n\n\n\nWarning\n\n\n\nIt is recommended to keep wf on its default value true. While the pattern distinctness and pattern stability estimators should still be unbiased because the residual degrees of freedom are adjusted, not whitening will lead to decreased precision and not filtering will retain low-frequency signal components which may act as a confound for experimental effects.\n\n\nDependent variables (columns of data matrices Ys) are only read from voxels within the SPM analysis brain mask after it was intersected with the union of region masks (if provided).\nmisc is a structure of fields containing additional information:\n\n\n\nmask\nlogical 3D volume indicating the voxels which dependent variables correspond to\n\n\nmat\n3D voxel indices to mm transformation matrix\n\n\nrmvi\nindices of dependent variables corresponding to each region, cell array of arrays\n\n\n\n\n\nmethod disp\ntextually display information about the object\nmodeledData.disp()\nThis method overrides Matlab’s disp, so you can also use disp(modeledData) or simply modeledData without semicolon to get the same output.\n\n\nmethod show\ngraphically display information about the object\nfig = analysis.show(rescale = true)\nThis method creates a figure showing the design matrices of all sessions.\nThe optional rescale specifies whether independent variables are individually rescaled to an absolute maximum of 1, to aid visibility of details.\nfig is the handle of the created figure.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#cvcrossmanova",
    "href": "reference.html#cvcrossmanova",
    "title": "API Reference documentation",
    "section": "class CvCrossManova",
    "text": "class CvCrossManova\nobject type representing data and analyses\n\nproperties\n\n\n\nYs\ncell array of per-session design matrices, observations × variables\n\n\nXs\ncell array of per-session data matrices, observations × regressors\n\n\nanalyses\ncell array of Analysis objects\n\n\nlambda\nstrength of regularization (0–1) towards Euclidean metric\n\n\nfs\narray of per-session residual degrees of freedom\n\n\nm\nnumber of sessions\n\n\nns\narray of per-session numbers of observations (rows)\n\n\nnResults\narray of per-analysis returned numbers of results\n\n\n\n\n\nconstructor CvCrossManova\ncreate CvCrossManova object\nccm = CvCrossManova(Ys, Xs, analyses, lambda = 1e-8, fs = ...)\nA CvCrossManova object stores data matrices, design matrices, analysis definitions, and further parameters. Upon creation, it also estimates GLM parameters and errors. Actual analyses are then performed on subsets of variables by calling the method runAnalyses.\nThe parameter λ (from 0 to 1) controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix. A small value can be used to improve the numerical and statistical stability of the estimate; the default is 10−8. A value of 1 can be used to disregard the covariance structure, because it replaces the estimated error covariance matrix by a diagonal matrix where every diagonal element is the average variance across variables. This can be useful for Cross-MANOVA if it is intended to quantify orthogonality w.r.t the original data space (Euclidean metric) instead of the whitened space.\nIf the per-session residual degrees of freedom fs are not specified, they are calculated under the assumption that the data observations are uncorrelated, as ns(k) - rank(Xs{k}). If the observations have been only approximately decorrelated or have been filtered, correct values should be explicitly specified.\n\n\nmethod runAnalyses\nrun the defined analyses on (a subset of) the variables\nDs = ccm.runAnalyses(vi)\nDs = ccm.runAnalyses()\nvi specifies the variables to be included in the analysis, as column indices into the data matrices Ys. If omitted, all variables are included.\nDs is a cell array of analysis results where each element results from the corresponding element in analyses. Whether this result is an estimate of pattern distinctness D or pattern stability D× depends on the contrasts and regressors involved in the analyses.\nFor an analysis which does not include permutations, the cell array element is a scalar; otherwise it is an array of permutation values, where the first element is the actual estimate (corresponding to the neutral permutation).\nTo determine how many values will be included in each of the elements of Ds before actually running an analysis, e.g. for preallocation, use the property nResults. It is a vector where each element gives the number of values returned for the corresponding analysis (i.e. the number of permutations).\n\n\nmethod checkEstimability\ncheck estimability of all analyses’ contrasts in all sessions\n[estimability, problems] = ccm.checkEstimability()\nestimability is a table with one row per session and one column per analysis & contrast. ‘true’ means that the contrast is estimable, ‘false’ that it is not estimable, ‘–’ that the contrast does not apply to the session. The check is performed via the function contrastEstimable.\nproblems indicates whether there are any inestimable contrasts (logical).\nIt is not usually necessary to use this method explicitly, because estimability is checked upon creation of a CvCrossManova object.\n\n\nmethod disp\ntextually display information about the object\ncm.disp()\nThis method overrides Matlab’s disp, so you can also use disp(cm) or simply cm without semicolon to get the same output.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#slsize",
    "href": "reference.html#slsize",
    "title": "API Reference documentation",
    "section": "function slSize",
    "text": "function slSize\nsearchlight size as a function of searchlight radius\npMax = slSize(slRadius)\nslSizes(slRadius = 5)\nWith the first syntax, the number of voxels corresponding to slRadius is returned as pMax. Note that this is the maximum number of voxels for a searchlight completely within the brain mask, at the borders the actual number will be smaller.\nWith the second syntax, a table of corresponding values of slRadius and pMax is printed. By default, the table includes slRadius values from 0 to 5, but another upper limit can be specified. The values of slRadius are chosen such that all possible searchlight sizes in that range are listed.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "tutorial-other/index.html",
    "href": "tutorial-other/index.html",
    "title": "Tutorial: Other data",
    "section": "",
    "text": "As an example for how to use the toolbox to analyze data other than fMRI, here we apply Cross-validated MANOVA as well as Cross-validated Cross-MANOVA to data from Kappenman et al. (2021). Their ERP CORE resource provides experimental material and data from paradigms eliciting seven standard ERP components.\n\nKappenman, E. S., Farrens, J. L., Zhang, W., Stewart, A. X., & Luck, S. J. (2021). ERP CORE: An open resource for human event-related potential research. NeuroImage, 225, 117465. https://doi.org/10.1016/j.neuroimage.2020.117465\nIn particular, we use the data of subject 1 from their P3 paradigm. In the Supplementary Materials the authors write:\n\nThe P3 was elicited in an active visual oddball paradigm. […] On each trial, one of five uppercase letters (A, B, C, D, or E […]) was presented for 200 ms in the center of the screen over the fixation point. […] Participants completed a total of 200 trials, divided into five blocks of 40 trials each. In each block, one letter was designated the target stimulus and the other four letters were designated non-targets. Participants pressed one button for targets and another button for non-targets. Each of the five letters served as a target in one block of the experiment and as a non-target in the other four blocks, with the order of blocks randomized across participants. Each letter was presented with equal probability within a block of trials (p = .2), such that the target category was rare (p = .2) and the non-target category was frequent (p = .8).\n\nThe analysis is broken down into several steps in the following subpages:\n\n\n\n\n\n\n\n\n\n\n\nPreparation\n\n\nData are downloaded and design information extracted\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Tutorial: Other data"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html",
    "href": "tutorial-fmri-spm/pairwise.html",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% directory with estimated model\nmodelDir = fullfile(sub, 'model');",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html#define-contrasts-and-analyses",
    "href": "tutorial-fmri-spm/pairwise.html#define-contrasts-and-analyses",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "Define contrasts and analyses",
    "text": "Define contrasts and analyses\nHaxby et al. used a pairwise correlation-based classifier applied to parameter estimates for each condition, estimated across even and odd sessions, respectively.\nCross-validated MANOVA replaces accuracy based on classification by explained multivariate variance based on contrasts. The equivalent of pairwise classification is a contrast with a 1 for one of the two categories, a −1 for the other, and zeros otherwise. We construct these 28 contrasts, and then analyses based on them using two folds, odd → even and even → odd:\n\n% construct pairwise contrasts and analyses\nanalyses = cell(nConds, nConds);\nodd = (mod(1 : nSessions, 2) == 1);\neven = (mod(1 : nSessions, 2) == 0);\nfor i = 1 : nConds\n    for j = i + 1 : nConds\n        C = zeros(nConds, 1);\n        C([i, j]) = [1, -1];\n        analyses{i, j} = Analysis(C, C, [odd ; even], [even ; odd]);\n    end\nend\n% reduce to defined analyses\nind = find(~cellfun(@isempty, analyses)) .';\nanalyses = analyses(ind);\n\nFor illustration, analysis #12 has this structure:\n\nanalyses{12}.show()",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html#run-analyses-on-region-of-interest",
    "href": "tutorial-fmri-spm/pairwise.html#run-analyses-on-region-of-interest",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "Run analyses on region of interest",
    "text": "Run analyses on region of interest\nHaxby et al. applied their analysis to several regions of interest. The data available to us contain masks for three regions, of which we here use the first.\n\n[Ds, ps] = cvCrossManovaRegion(modelDir, regions(1), analyses);\n\n\ncvCrossManovaRegion\n\nloading data via subj1/model/SPM.mat\n  volume of 40 × 64 × 64 = 163840 voxels\n  27638 voxels within brain mask\n    572 voxels within brain mask in subj1/mask4_vt.nii\n  572 voxels within brain mask in all regions\n  reading images from subj1/rbold.nii,????\n  1452 of 1452 volumes loaded\n  whitening\n  high-pass-filtering\n\n\nDot indexing is not supported for variables of this type.\nError in cvCrossManovaRegion (line 30)\nnRegions = numel(misc.rmvi);\n\n\nThe results are contained in column 1 of the cell array Ds. We assemble them into a matrix, filling in the identical values in the lower triangular part and leaving zeros on the diagonal, and visualise the matrix as a heatmap:\n\n% assemble\nDsMatrix = zeros(nConds, nConds);\nDsMatrix(ind) = [Ds{:, 1}];\nDsMatrix = DsMatrix + DsMatrix .';\n% visualize\nfig = figure();\nfig.Position(3:4) = [750, 674];\nheatmap(conditions, conditions, DsMatrix, ...\n    FontName=get(0, 'defaultTextFontName'));\nylabel(gca().NodeChildren(2), 'D')\n\nUndefined variable 'Ds'.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html#comparison-with-original-analysis-results",
    "href": "tutorial-fmri-spm/pairwise.html#comparison-with-original-analysis-results",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "Comparison with original analysis results",
    "text": "Comparison with original analysis results\nHaxby et al.’s main result (Table 1) was the identification accuracy for each of the eight categories averaged across classification pairs, and then averaged across six subjects. For ‘all ventral temporal object-selective cortex’, presumably corresponding to the first of the available masks (mask4_vt.nii) they reported the following accuracies (in percent):\n\nmeanAcc = [100, 100,  98,  90,  92,  92,  96, 100];\n\nOur corresponding result is the average pattern distinctness across the 7 pairwise contrasts each category was involved in:\n\nmeanD = sum(DsMatrix) / (nConds - 1)\n\nmeanD =\n     0     0     0     0     0     0     0     0\n\n\nPlotted against each other:\n\nfig = figure();\nfig.Position(3:4) = [750, 713];\nfor i = 1 : nConds\n    plot(meanAcc(i), meanD(i), '.', Color=colors(i), MarkerSize=20)\n    hold all\nend\nlegend(conditions, Interpreter=\"none\", Location=\"NorthWest\")\nxlim([89, 101])\nylim([0.45, 1.15])\nxlabel(\"mean accuracy / %\")\nylabel(\"mean pattern distinctness\")\n\n\n\n\n\n\n\n\n\n\nThe ranking is similar though not identical. Note that the results cannot be completely equivalent since our analysis is based on one subject, while the mean accuracy is additionally averaged across subjects.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html",
    "href": "tutorial-fmri-spm/model.html",
    "title": "Model",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% BOLD data (contains realignment information)\nfnBOLD = fullfile(sub, 'bold.nii');\n% realigned BOLD data\nfnrBOLD = fullfile(sub, 'rbold.nii');\n% directory for model\nmodelDir = fullfile(sub, 'model');\n% file containing model\nfnSPM = fullfile(modelDir, 'SPM.mat');",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html#specify-the-model",
    "href": "tutorial-fmri-spm/model.html#specify-the-model",
    "title": "Model",
    "section": "Specify the model",
    "text": "Specify the model\nInstead of the approach of the paper to use a single design matrix across all sessions, we here follow the standard approach of SPM, and use session-wise design matrices. Each of them contains eight HRF-convoluted regressors corresponding to the stimulus presentations of the eight conditions, six motion regressors derived from the realignment parameters, and a constant regressor.\n\n% get realignment parameters for motion regressors\nV = spm_vol(fnBOLD);\nmat = cat(4, V.mat);\n\n% create directory\nmkdir(modelDir)\n\n% SPM module 'fMRI model specification'\nfmri_spec = struct;\nfmri_spec.dir = {modelDir};         % model directory\nfmri_spec.timing.units = 'secs';    % units for onsets and durations\nfmri_spec.timing.RT = TR;           % repetition time (interscan interval)\nfmri_spec.timing.fmri_t = 25;       % microtime resolution: 0.1 s\nfmri_spec.timing.fmri_t0 = 12;      % microtime onset: middle of scan\n% for each session\nfor si = 1 : nSessions\n    % indices of scans in 4d BOLD image corresponding to session\n    vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);\n    fmri_spec.sess(si).scans = arrayfun(@(i) ...\n        sprintf('%s,%d', ...                % SPM's &lt;filename&gt;,&lt;scan&gt; syntax\n            fullfile(pwd, fnrBOLD), i), ... % filename must include full path\n            vi, ...\n            'UniformOutput', false)';\n    % for each condition\n    for ci = 1 : nConds\n        % name, onsets, and durations\n        fmri_spec.sess(si).cond(ci).name = conditions{ci};\n        fmri_spec.sess(si).cond(ci).onset = onsets{si, ci};\n        fmri_spec.sess(si).cond(ci).duration = durations{si, ci};\n        fmri_spec.sess(si).cond(ci).tmod = 0;   % no time modulation\n        fmri_spec.sess(si).cond(ci).orth = 1;\n    end\n    fmri_spec.sess(si).multi = {''};        % no 'multiple conditions'\n    % motion regressors from realignment parameters\n    Q = nan(nVolsPerSession, 6);\n    for i = 1 : nVolsPerSession\n        qq = spm_imatrix(mat(:, :, vi(i)) / mat(:, :, vi(1)));\n        Q(i, :) = qq(1 : 6);\n    end\n    for mi = 1 : 6\n        fmri_spec.sess(si).regress(mi).name = sprintf('motion(%d)', mi);\n        fmri_spec.sess(si).regress(mi).val = Q(:, mi);\n    end\n    fmri_spec.sess(si).multi_reg = {''};    % no 'multiple regressors'\n    fmri_spec.sess(si).hpf = 128;           % high-pass cutoff time (def.)\nend\nfmri_spec.bases.hrf.derivs = [0 0]; % no HRF derivatives\nfmri_spec.volt = 1;                 % do not model interactions\nfmri_spec.global = 'None';          % no global intensity normalization\nfmri_spec.mthresh = 0.8;            % masking threshold (def.)\nfmri_spec.mask = {''};              % no explicit mask\nfmri_spec.cvi = 'AR(1)';            % model serial correlations as AR(1) (def.)\n% run module\nmatlabbatch = {};\nmatlabbatch{1}.spm.stats.fmri_spec = fmri_spec;\nspm_jobman('run', matlabbatch(1))\n\nInitialising batch system... done.\n\n\n------------------------------------------------------------------------\n05-Nov-2023 01:52:49 - Running job #1\n------------------------------------------------------------------------\n05-Nov-2023 01:52:50 - Running 'fMRI model specification'\n\nSPM12: spm_fMRI_design (v7739)                     01:52:50 - 05/11/2023\n========================================================================\nSaving fMRI design                      :               ...SPM.mat saved\n\nSPM12: spm_fmri_spm_ui (v7738)                     01:52:50 - 05/11/2023\n========================================================================\nMapping files                           :                        ...done\nCalculating globals                     :                        ...done\nSaving SPM configuration                :               ...SPM.mat saved\nSaving SPM configuration                :               ...SPM.mat saved\nCompleted                               :          01:53:02 - 05/11/2023\n05-Nov-2023 01:53:02 - Done    'fMRI model specification'\n05-Nov-2023 01:53:02 - Done",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html#visualize-the-model",
    "href": "tutorial-fmri-spm/model.html#visualize-the-model",
    "title": "Model",
    "section": "Visualize the model",
    "text": "Visualize the model\n\nload(fullfile(modelDir, 'SPM.mat'), 'SPM')\nfilenames = SPM.xY.P(:, numel(pwd) + 2 : end);\nfilenames = reshape(cellstr(filenames), size(SPM.xY.VY));\nspm_DesRep('DesMtx', SPM.xX, filenames, SPM.xsDes);",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html#estimate-the-model",
    "href": "tutorial-fmri-spm/model.html#estimate-the-model",
    "title": "Model",
    "section": "Estimate the model",
    "text": "Estimate the model\n\n% SPM module 'fMRI model estimation'\nfmri_est = struct;\nfmri_est.spmmat = {fnSPM};          % path to `SPM.mat`\nfmri_est.write_residuals = 0;       % do not write residuals\nfmri_est.method.Classical = 1;      % frequentist statistical estimation\n% run module\nmatlabbatch = {};\nmatlabbatch{1}.spm.stats.fmri_est = fmri_est;\nspm_jobman('run', matlabbatch(1))\n\n\n\n------------------------------------------------------------------------\n05-Nov-2023 01:53:09 - Running job #1\n------------------------------------------------------------------------\n05-Nov-2023 01:53:09 - Running 'Model estimation'\n\nSPM12: spm_spm (v7738)                             01:53:09 - 05/11/2023\n========================================================================\n\nSPM12: spm_est_non_sphericity (v7577)              01:53:12 - 05/11/2023\n========================================================================\nChunk   2/2                             :                        ...done\nTemporal non-sphericity (27073 voxels)  :             ...ReML estimation\n  ReML Block 1                \n  ReML Iteration 1                      :        ...9.827664e+00 [+4.25]\n  ReML Iteration 2                      :        ...5.884532e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.599118e-02 [+4.75]\n  ReML Block 2                \n  ReML Iteration 1                      :        ...1.118494e+01 [+4.25]\n  ReML Iteration 2                      :        ...8.181662e-01 [+4.50]\n  ReML Iteration 3                      :        ...2.286568e-02 [+4.75]\n  ReML Block 3                \n  ReML Iteration 1                      :        ...6.901230e+00 [+4.25]\n  ReML Iteration 2                      :        ...1.429964e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.248735e-03 [+4.75]\n  ReML Block 4                \n  ReML Iteration 1                      :        ...9.365361e+00 [+4.25]\n  ReML Iteration 2                      :        ...3.411252e-01 [+4.50]\n  ReML Iteration 3                      :        ...5.701104e-03 [+4.75]\n  ReML Block 5                \n  ReML Iteration 1                      :        ...1.027357e+01 [+4.25]\n  ReML Iteration 2                      :        ...4.295659e-01 [+4.50]\n  ReML Iteration 3                      :        ...7.688102e-03 [+4.75]\n  ReML Block 6                \n  ReML Iteration 1                      :        ...1.323103e+01 [+4.25]\n  ReML Iteration 2                      :        ...3.478206e-01 [+4.50]\n  ReML Iteration 3                      :        ...6.419885e-03 [+4.75]\n  ReML Block 7                \n  ReML Iteration 1                      :        ...1.774148e+01 [+4.25]\n  ReML Iteration 2                      :        ...1.183276e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.092870e-03 [+4.75]\n  ReML Block 8                \n  ReML Iteration 1                      :        ...1.752418e+01 [+4.25]\n  ReML Iteration 2                      :        ...1.037713e-01 [+4.50]\n  ReML Iteration 3                      :        ...8.001813e-04 [+4.75]\n  ReML Block 9                \n  ReML Iteration 1                      :        ...2.328423e+01 [+4.25]\n  ReML Iteration 2                      :        ...8.247045e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.707144e-02 [+4.75]\n  ReML Block 10               \n  ReML Iteration 1                      :        ...2.362216e+01 [+4.25]\n  ReML Iteration 2                      :        ...2.052704e-01 [+4.50]\n  ReML Iteration 3                      :        ...9.280063e-04 [+4.75]\n  ReML Block 11               \n  ReML Iteration 1                      :        ...7.029397e+00 [+4.25]\n  ReML Iteration 2                      :        ...4.771267e-03 [+4.50]\n  ReML Block 12               \n  ReML Iteration 1                      :        ...7.075062e+00 [+4.25]\n  ReML Iteration 2                      :        ...5.880034e-02 [+4.50]\n\nSPM12: spm_spm (v7738)                             01:53:18 - 05/11/2023\n========================================================================\nChunk   2/2                             :                        ...done\nSpatial non-sphericity (over scans)     :                        ...done\nSaving SPM.mat                          :                        ...done\nCompleted                               :          01:53:28 - 05/11/2023\nDone\n05-Nov-2023 01:53:28 - Done    'Model estimation'\n05-Nov-2023 01:53:28 - Done\n\n\n\nOur analyses only need the updates to the SPM.mat file made during estimation, not the parameter estimates themselves. We therefore delete the created beta_####.nii files.\n\nload(fnSPM, 'SPM');\nfor i = 1 : numel(SPM.Vbeta)\n    spm_unlink(fullfile(modelDir, SPM.Vbeta(i).fname))\nend",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/index.html",
    "href": "tutorial-fmri-spm/index.html",
    "title": "Tutorial: fMRI with SPM",
    "section": "",
    "text": "As an example for how to use the toolbox to analyze fMRI data, here we apply Cross-validated MANOVA as well as Cross-validated Cross-MANOVA to the data of subject 1 from Haxby et al. (2001).\n\nHaxby, J. V., Gobbini, M. I., Furey, M. L., Ishai, A., Schouten, J. L., & Pietrini, P. (2001). Distributed and Overlapping Representations of Faces and Objects in Ventral Temporal Cortex. Science, 293, 2425–2430. https://doi.org/10.1126/science.1063736\nThe details of the experiment and analysis are presented in footnotes. From Footnote 18:\n\nStimuli were gray-scale images of faces, houses, cats, bottles, scissors, shoes, chairs, and nonsense patterns. The categories were chosen so that all stimuli from a given category would have the same base level name. […]\nTwelve time series were obtained in each subject. Each time series began and ended with 12 s of rest and contained eight stimulus blocks of 24-s duration, one for each category, separated by 12-s intervals of rest. Stimuli were presented for 500 ms with an interstimulus interval of 1500 ms. […]\nTo determine the patterns of response to each category on even-numbered and odd-numbered runs, we used a 16-regressor model—eight regressors to model the response to each category relative to rest on even runs and eight regressors to model the response to each category on odd runs with no regressor that contrasted all stimulus blocks to rest.\n\nFrom Footnote 19:\n\nAnalysis of the accuracy with which the category being viewed could be identified focused on comparisons between patterns of response for pairs of categories […]\nIf the within-category correlation (for example, response to category A on even and odd runs) was larger than the between-category correlation (correlation of the response to category A on even runs with the response to category B on odd runs), that comparison was counted as a correct identiﬁcation.\n\nThe main result of the paper is the identification accuracy for each category, determined in a several different regions of interest and presented in Table 1.\nOur analysis is broken down into several steps in the following subpages:\n\n\n\n\n\n\n\n\n\n\n\n\nPreparation\n\n\nData are downloaded, preprocessed, and design information extracted\n\n\n\n\n\n\n\n\n\n\n\n\nModel\n\n\nA model for the data is set up and estimated in SPM\n\n\n\n\n\n\n\n\n\n\n\n\nCross-validated MANOVA\n\n\nPattern distinctness is computed in regions of interest and via searchlight\n\n\n\n\n\n\n\n\n\n\n\n\nPairwise Cross-validated MANOVA\n\n\nPattern distinctness is computed in a way approximating the original analysis\n\n\n\n\n\n\n\n\n\n\n\n\nCross-validated Cross-MANOVA\n\n\nPattern stability is computed in regions of interest and via searchlight\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Tutorial: fMRI with SPM"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CvCrossManova Toolbox",
    "section": "",
    "text": "Warning\n\n\n\nThis project is under development.\n\n\nCvCrossManova is a toolbox for Matlab which implements the Cross-validated MANOVA and Cross-validated Cross-MANOVA algorithms.\nCross-validated MANOVA was introduced by Allefeld & Haynes (2014) as a method for multivariate pattern analysis (MVPA) in fMRI. Unlike most MVPA methods, it is not based on the accuracy of a classification algorithm, but estimates the multivariate variance explained by a contrast applied to a general linear model (GLM), called pattern distinctness D. Using the GLM has the advantage of a common basis with univariate fMRI analyses, resulting in an interpretable measure of effect size, and being applicable to designs where there are no classes. Other than standard GLM-based methods however, it uses cross-validation to obtain an unbiased estimator of that explained multivariate variance.\n\nAllefeld, C., & Haynes, J.-D. (2014). Searchlight-based multi-voxel pattern analysis of fMRI by cross-validated MANOVA. NeuroImage, 89, 345–357. https://doi.org/10.1016/j.neuroimage.2013.11.043\nA limitation of Cross-validated MANOVA was that it provided no analog of cross-classification, i.e. training a classifier on one pair of classes and testing it on another pair of classes, though the original paper pointed to the possibility to use interaction contrasts for a similar purpose. In recent papers, we used an adapted version of Cross-validated MANOVA which uses two different contrasts for ‘training’ and ‘validation’, called Cross-validated Cross-MANOVA, but it was published only in the methods sections of these papers. A forthcoming methodological paper will remedy that, and the CvCrossManova toolbox is the corresponding implementation. Cross-validated Cross-MANOVA estimates the explained multivariate variance shared between two contrasts, called pattern stability D×.\nAn implementation of Cross-validated MANOVA was provided previously by the CvManova toolbox. Because Cross-validated MANOVA is a special case of Cross-validated Cross-MANOVA, the CvCrossManova toolbox implements both and is therefore an extended revision.\nThese pages document how to use the CvCrossManova toolbox to estimate both pattern distinctness and pattern stability, including both an example of analysing fMRI data supported by SPM and other data (in this case EEG).\n\n\n\n\n\n\nInstallation\n\n\nHow to download and install the toolbox and its dependencies\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial: fMRI with SPM\n\n\nExample analysis of data of Haxby et al. (2001)\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial: Other data\n\n\nExample analysis of data of Kappenman et al. (2021)\n\n\n\n\n\n\n\n\n\n\n\n\nAPI Reference documentation\n\n\nDetailed information about toolbox functions and classes\n\n\n\n\n\n\n\n\n\n\nNo matching items\n\n\n\nThe CvCrossManova toolbox is copyrighted © 2023 by Carsten Allefeld and released under the terms of the GNU General Public License, version 3 or later. Remi Gau, Polina Iamshchinina, and Thomas Christophel contributed to earlier versions of the code.\nThis documentation was created with Quarto using a slightly modified Cosmo Bootswatch theme. It is set in Source Sans 3 and Source Code Pro. Matlab code was executed using MKernel."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "The CvCrossManova toolbox has been developed with Matlab R2023b, but should work with later and slightly earlier versions. The core functionality does not depend on other toolboxes. However, functions which read data modeled in SPM (cvCrossManovaRegion, cvCrossManovaSearchlight, ModeledData.fromSPM) depend on it being installed. You can download SPM from the pages of the Functional Imaging Lab at UCL. The toolbox was developed using SPM12 r7771, but later and slightly earlier versions should work, too.\nTo install the toolbox, download the file cvcrossmanova-v#.#.#.zip attached to the latest GitHub release. Unzip the file into a directory, and make sure that the created directory cvcrossmanova-v#.#.#/ is on the Matlab search path. If you update the toolbox to a newer version, make sure that the old version is no longer on the path.\nThe code for the toolbox as well as this documentation is maintained in a git repository on GitHub. If you need the latest not yet released version, clone the repository with\ngit clone https://github.com/allefeld/cvcrossmanova.git\nand copy the files in the toolbox/ subdirectory into a directory on the Matlab search path.\nIf you found a bug or have an idea for improvement, you can create an issue on the repository.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html",
    "href": "tutorial-fmri-spm/preparation.html",
    "title": "Preparation",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% start from scratch\n[~] = rmdir(sub, 's');  % FIXME\n\nThe data for the subject are downloaded from PyMVPA as a .tar.gz archive, and the archive is unpacked.\n\nfn = [sub '-2010.01.14.tar.gz'];\nurl = ['http://data.pymvpa.org/datasets/haxby2001/' fn];\nwebsave(fn, url);       % FIXME\nuntar(fn)               % FIXME\ndelete(fn)              % FIXME\n\nThe included NIfTI images are individually gzip-compressed and need to be uncompressed.\n\nfiles = dir(fullfile(sub, '*.nii.gz'));\nfor i = 1 : numel(files)\n    fprintf('uncompressing %s\\n', files(i).name)\n    gunzip(fullfile(sub, files(i).name))\n    delete(fullfile(sub, files(i).name))\nend\n\nuncompressing anat.nii.gz\nuncompressing bold.nii.gz\nuncompressing mask4_vt.nii.gz\nuncompressing mask8_face_vt.nii.gz\nuncompressing mask8_house_vt.nii.gz\nuncompressing mask8b_face_vt.nii.gz\nuncompressing mask8b_house_vt.nii.gz\n\n\nThe mask images are not documented in detail. Based on the filenames and the in-mask volume, we assume the following correspondence between regions listed in Table 1 of the paper and mask image files:\n\n\n\nmask4_vt.nii\n‘all ventral temporal object-selective cortex’\n\n\nmask8b_face_vt.nii\n‘region maximally responsive to faces’\n\n\nmask8b_house_vt.nii\n‘region maximally responsive to houses’\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nTODO: do they need to be aligned to the anatomical or the mean BOLD image?\n\n\n\nfnBOLD = fullfile(sub, 'bold.nii');\nregions = {fullfile(sub, 'mask4_vt.nii'), ...\n           fullfile(sub, 'mask8b_face_vt.nii'), ...\n           fullfile(sub, 'mask8b_house_vt.nii')};",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#download-and-unpack-data",
    "href": "tutorial-fmri-spm/preparation.html#download-and-unpack-data",
    "title": "Preparation",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% start from scratch\n[~] = rmdir(sub, 's');  % FIXME\n\nThe data for the subject are downloaded from PyMVPA as a .tar.gz archive, and the archive is unpacked.\n\nfn = [sub '-2010.01.14.tar.gz'];\nurl = ['http://data.pymvpa.org/datasets/haxby2001/' fn];\nwebsave(fn, url);       % FIXME\nuntar(fn)               % FIXME\ndelete(fn)              % FIXME\n\nThe included NIfTI images are individually gzip-compressed and need to be uncompressed.\n\nfiles = dir(fullfile(sub, '*.nii.gz'));\nfor i = 1 : numel(files)\n    fprintf('uncompressing %s\\n', files(i).name)\n    gunzip(fullfile(sub, files(i).name))\n    delete(fullfile(sub, files(i).name))\nend\n\nuncompressing anat.nii.gz\nuncompressing bold.nii.gz\nuncompressing mask4_vt.nii.gz\nuncompressing mask8_face_vt.nii.gz\nuncompressing mask8_house_vt.nii.gz\nuncompressing mask8b_face_vt.nii.gz\nuncompressing mask8b_house_vt.nii.gz\n\n\nThe mask images are not documented in detail. Based on the filenames and the in-mask volume, we assume the following correspondence between regions listed in Table 1 of the paper and mask image files:\n\n\n\nmask4_vt.nii\n‘all ventral temporal object-selective cortex’\n\n\nmask8b_face_vt.nii\n‘region maximally responsive to faces’\n\n\nmask8b_house_vt.nii\n‘region maximally responsive to houses’\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\nTODO: do they need to be aligned to the anatomical or the mean BOLD image?\n\n\n\nfnBOLD = fullfile(sub, 'bold.nii');\nregions = {fullfile(sub, 'mask4_vt.nii'), ...\n           fullfile(sub, 'mask8b_face_vt.nii'), ...\n           fullfile(sub, 'mask8b_house_vt.nii')};",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#obtain-experimental-design-information",
    "href": "tutorial-fmri-spm/preparation.html#obtain-experimental-design-information",
    "title": "Preparation",
    "section": "Obtain experimental design information",
    "text": "Obtain experimental design information\nThe BOLD data are contained in a single 4-dimensional NIfTI file.\n\nN = nifti(fnBOLD);\nsize(N.dat)\ndiag(N.mat(1:3, 1:3))'\nTR = N.timing.tspace\n\nans =\n          40          64          64        1452\nans =\n         -3.5         3.75         3.75\nTR =\n          2.5\n\n\nThis file contains a timeseries of 1452 scans at at repetition time of 2.5 s, each of which has 40 × 64 × 64 voxels of size 3.5 × 3.75 × 3.75 mm.\nThere were 12 sessions, each of which consisted of 8 stimulus blocks of 24 s. There were rest periods of 12 s each at the beginning, end, and in between blocks. Each session therefore had a duration of (12 + 24) × 8 + 12 = 300 s, corresponding to 120 TRs (121 scans).\nInformation about the onsets and durations of stimuli in this subject are contained in a file labels.txt.\n\nlabels = readtable(fullfile(sub, 'labels.txt'), 'Delimiter', ' ');\nhead(labels)\n\n       labels       chunks\n    ____________    ______\n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'scissors'}      0   \n    {'scissors'}      0   \n\n\n\ntail(labels)\n\n       labels       chunks\n    ____________    ______\n    {'scissors'}      11  \n    {'scissors'}      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n\n\nIt has 1452 rows, corresponding to the scans of the BOLD data. The format is not documented, but it appears that the column labels contains the experimental condition (stimulus type), and the column chunk distinguishes the 12 sessions by an index from 0 to 11, each with 121 rows. In the order of the paper, the condition names are\n\nconditions = [\"face\", \"house\", \"cat\", \"bottle\", ...\n    \"scissors\", \"shoe\", \"chair\", \"scrambledpix\"];\n\nplus \"rest\" for the rest intervals. Stimulus blocks comprise 9 rows with rest intervals of 5 or 6 rows, which does not exactly correspond to the description above because the stimulus presentation length is incompatible with the TR.\nWe therefore use these data only to extract the condition index for each block, but recreate more precise stimulus timing information.\n\nnSessions = 12;\nnConds = numel(conditions);\nonsets = cell(nSessions, nConds);\ndurations = cell(nSessions, nConds);\n% for each session\nfor si = 1 : nSessions\n    % extract condition for each block (from its middle)\n    cond = labels.labels(labels.chunks == si - 1);\n    [~, condInd] = ismember(cond, conditions);\n    condInd = condInd(round((24 :(12 + 24): 300) / TR) + 1);\n    assert(isequal(sort(condInd).', 1:8))\n    % for each condition\n    for ci = 1 : nConds\n        % assemble stimulus onset and duration information in s\n        blockInd = find(condInd == ci);\n        blockStart = (blockInd - 1) * (12 + 24) + 12;\n        onsets{si, ci} = blockStart + (0 : 11) * (0.5 + 1.5);\n        durations{si, ci} = 0.5 * ones(1, 12);\n    end\nend\nnVolsPerSession = height(labels) / nSessions;\n\nVisualization of stimulus onsets in each session:\n\nfig = figure;\nfig.Position(3:4) = [750, 400];\ncolors = [\"#000000\", \"#ff9b00\", \"#a6ee00\", \"#00eea6\", ...\n    \"#009bff\", \"#a600ff\", \"#ff00a6\", \"#aaaaaa\"];\nfor ci = 1 : nConds\n    ons = [];\n    ses = [];\n    for si = 1 : nSessions\n        ons = [ons, onsets{si, ci}];\n        ses = [ses, si * ones(size(onsets{si, ci}))];\n    end\n    plot(ons, ses, '.', 'Color', colors(ci))\n    hold all\nend\nxlim([-1 , nVolsPerSession] * TR)\nylim([0.5, nSessions + 0.5])\nset(gca, 'YTick', 1 : nSessions)\nset(gca, 'YDir', 'reverse')\nylabel('session')\nxlabel('time / s')\nlegend(conditions, Location=\"eastoutside\")",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#realign-bold-data",
    "href": "tutorial-fmri-spm/preparation.html#realign-bold-data",
    "title": "Preparation",
    "section": "Realign BOLD data",
    "text": "Realign BOLD data\n\nfnrBOLD = fullfile(sub, 'rbold.nii');\nmatlabbatch = {};\nfor si = 1 : nSessions\n    vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);\n    vn = arrayfun(@(i) sprintf('%s,%d', fnBOLD, i), ...\n        vi, 'UniformOutput', false);\n    matlabbatch{1}.spm.spatial.realign.estwrite.data{si} = vn';\nend\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.quality = 0.9;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.sep = 4;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.fwhm = 5;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.rtm = 1;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.interp = 2;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.wrap = [0 0 0];\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.weight = '';\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.which = [2 1];\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.interp = 4;\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.wrap = [0 0 0];\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.mask = 1;\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.prefix = 'r';\nspm_jobman('run', matlabbatch)  % FIXME\n\nInitialising batch system... done.\n\n\n------------------------------------------------------------------------\n05-Nov-2023 01:45:35 - Running job #1\n------------------------------------------------------------------------\n05-Nov-2023 01:45:35 - Running 'Realign: Estimate & Reslice'\n\nSPM12: spm_realign (v7141)                         01:45:35 - 05/11/2023\n========================================================================\nCompleted                               :          01:50:17 - 05/11/2023\n\nSPM12: spm_reslice (v7141)                         01:50:17 - 05/11/2023\n========================================================================\nCompleted                               :          01:52:15 - 05/11/2023\n05-Nov-2023 01:52:15 - Done    'Realign: Estimate & Reslice'\n05-Nov-2023 01:52:16 - Done",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#save-information",
    "href": "tutorial-fmri-spm/preparation.html#save-information",
    "title": "Preparation",
    "section": "Save information",
    "text": "Save information\n\nsave(fullfile(sub, 'info.mat'), 'regions', 'TR', 'nSessions', ...\n    'nVolsPerSession', 'conditions', 'nConds', 'onsets', 'durations', 'colors')",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html",
    "href": "tutorial-fmri-spm/cvmanova.html",
    "title": "Cross-validated MANOVA",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% directory with estimated model\nmodelDir = fullfile(sub, 'model');",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#define-contrasts",
    "href": "tutorial-fmri-spm/cvmanova.html#define-contrasts",
    "title": "Cross-validated MANOVA",
    "section": "Define contrasts",
    "text": "Define contrasts\nWe are looking at two effects:\n\nthe ‘effect of category’, i.e. quantifying how much patterns associated with the eight different stimulus categories differ from each other and\nthe ‘effect of category within inanimate object’, i.e. quantifying how much patterns associated with ‘bottle’, ‘scissors’, ‘shoe’, and ‘chair’ differ from each other.\n\nThe corresponding contrasts consist of 7 and 3 subcontrasts (columns), respectively, each of which targets the difference between two conditions.\n\nC_stimulus = ...\n    [  1  0  0  0  0  0  0      % face\n      -1  1  0  0  0  0  0      % house\n       0 -1  1  0  0  0  0      % cat\n       0  0 -1  1  0  0  0      % bottle\n       0  0  0 -1  1  0  0      % scissors\n       0  0  0  0 -1  1  0      % shoe\n       0  0  0  0  0 -1  1      % chair\n       0  0  0  0  0  0 -1 ];   % scrambledpix\nC_object_category = ...\n    [  0  0  0                  % face\n       0  0  0                  % house\n       0  0  0                  % cat\n       1  0  0                  % bottle\n      -1  1  0                  % scissors\n       0 -1  1                  % shoe\n       0  0 -1                  % chair\n       0  0  0 ];               % scrambledpix\n\nNote that though the subcontrasts only combine neighboring conditions, the null hypothesis defined by all of them together says that there is no difference in the patterns associated with any of the involved conditions. For example for C_object_category, the three subcontrasts state\n\npattern of ‘bottle’ = pattern of ‘scissors’,\npattern of ‘scissors’ = pattern of ‘shoe’, and\npattern of ‘shoe’ = pattern of ‘chair’.\n\nIf all three statements hold, that also implies that there is no difference e.g. between the pattern of ‘bottle’ and the pattern of ‘chair’. The result of cross-validated MANOVA, pattern distinctness D, estimates how much of the multivariate variance deviates from the null hypothesis encoded in a contrast.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#define-analyses",
    "href": "tutorial-fmri-spm/cvmanova.html#define-analyses",
    "title": "Cross-validated MANOVA",
    "section": "Define analyses",
    "text": "Define analyses\nAn analysis is represented by an object of class Analysis. It comprises two contrasts, for ‘training’ (A) and ‘validation’ (B), but for cross-validated MANOVA the two are identical. It also defines a validation scheme which for each fold specifies which sessions are used for ‘training’ and ‘validation’. Here we use standard leave-one-session-out cross-validation, but more complex schemes can be defined.\n\nanalysis_stimulus = Analysis.leaveOneSessionOut(nSessions, C_stimulus)\n\nanalysis_stimulus = \n  Analysis:\n    12 fold(s), 12 session(s)\n    CA = CB:  8 × 7, 7-dimensional\n    no permutations (besides neutral)\n\n\n\nanalysis_object_category = Analysis.leaveOneSessionOut( ...\n    nSessions, C_object_category)\n\nanalysis_object_category = \n  Analysis:\n    12 fold(s), 12 session(s)\n    CA = CB:  8 × 3, 3-dimensional\n    no permutations (besides neutral)\n\n\nBy default no permutations are performed, but that can be requested explicitly. We here limit the number of permutations to 100, though a larger number is recommended if available.\n\nrng(1837146515, 'twister')\nanalysis_object_category.addPermutations(maxPerms=100)\n\n2048 permutations possible\nrandomly selecting a subset of 100 permutations\n\n\nIf the requested number of permutations (parameter maxPerms, default 1000) is larger than or equal to the number of possible permutations, all possible permutations are performed; if not, a subset is chosen randomly. For reproducibility of analyses it is advisable to explicitly initialize Matlab’s random number generator with rng. The arguments used here were originally chosen based on the fields Seed and Type from s = rng('shuffle').\nAs seen above, evaluating an Analysis object prints a brief summary. It can also be visualized using the method show:\n\nanalysis_object_category.show()\n\n\n\n\n\n\n\n\n\n\nBelow we need a cell array which contains all Analysis objects.\n\nanalyses = {analysis_stimulus, analysis_object_category};",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#run-analyses-on-regions-of-interest",
    "href": "tutorial-fmri-spm/cvmanova.html#run-analyses-on-regions-of-interest",
    "title": "Cross-validated MANOVA",
    "section": "Run analyses on regions of interest",
    "text": "Run analyses on regions of interest\nTo perform region-of-interest analyses, use the function cvCrossManovaRegion. It\n\nloads the data via the SPM.mat file in modelDir, restricted to the voxels in the regions specified via regions,\ncreates an object of class CvCrossManova which includes the data, design matrices, and the specified analyses,\nand then runs the analyses on the regions and returns the results.\n\nThe output first reports on loading the data and then displays the created CvCrossManova object, including information on the contained analyses.\n\n[Ds, ps] = cvCrossManovaRegion(modelDir, regions, analyses);\n\n\ncvCrossManovaRegion\n\nloading data via subj1/model/SPM.mat\n  volume of 40 × 64 × 64 = 163840 voxels\n  27638 voxels within brain mask\n    572 voxels within brain mask in subj1/mask4_vt.nii\n    21 voxels within brain mask in subj1/mask8b_face_vt.nii\n    225 voxels within brain mask in subj1/mask8b_house_vt.nii\n  572 voxels within brain mask in all regions\n  reading images from subj1/rbold.nii,????\n  1452 of 1452 volumes loaded\n  whitening\n  high-pass-filtering\n\n\nDot indexing is not supported for variables of this type.\nError in cvCrossManovaRegion (line 30)\nnRegions = numel(misc.rmvi);\n\n\nThe result ps is an array with the number of voxels in each region.\n\nps\n\nUnrecognized function or variable 'ps'.\n\n\nThe result Ds is a cell array with one row for each analysis, and one column for each region. For the first analysis each cell contains a scalar, which is the estimated value of D.\n\nDs(1, :)\n\nUnrecognized function or variable 'Ds'.\n\n\n\n\nUndefined variable 'Ds'.\n\n\nFor the second analysis each cell contains an array with 100 elements, corresponding to the 100 permutations we requested. The first value is the actual estimated value of D, the others are permutation values.\n\nDs(2, :)\n\nUnrecognized function or variable 'Ds'.\n\n\n\n\nUndefined variable 'Ds'.\n\n\nBased on this, we can calculate a p-value for the null hypothesis ‘no effect of category within inanimate object’, in each region.\n\nfor i = 1 : numel(regions)\n    D = Ds{2, i};\n    pval = mean(D &gt;= D(1));\n    fprintf('%-25s  D = %.4f  p = %g\\n', regions{i}, D(1), pval)\nend\n\nUndefined variable 'Ds'.\n\n\nThe null hypothesis can be rejected in all three regions.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#run-analyses-with-searchlight",
    "href": "tutorial-fmri-spm/cvmanova.html#run-analyses-with-searchlight",
    "title": "Cross-validated MANOVA",
    "section": "Run analyses with searchlight",
    "text": "Run analyses with searchlight\nTo perform searchlight analyses, use the function cvCrossManovaSearchlight. It\n\nloads the data via the SPM.mat file in modelDir,\ncreates an object of class CvCrossManova which includes the data, design matrices, and the specified analyses,\nand then runs the analyses on the voxels included in each searchlight.\n\nThe output first reports on loading the data and then displays the created CvCrossManova object, including information on the contained analyses.\n\nslRadius = 3;\ncvCrossManovaSearchlight(modelDir, slRadius, analyses)  % FIXME\n\n\ncvCrossManovaSearchlight\n\nloading data via subj1/model/SPM.mat\n  volume of 40 × 64 × 64 = 163840 voxels\n  27638 voxels within brain mask\n  no region masks\n  reading images from subj1/rbold.nii,????\n  1452 of 1452 volumes loaded\n  whitening\n  high-pass-filtering\n\ncomputing Cross-validated (Cross-) MANOVA\n\n\nDot indexing is not supported for variables of this type.\nError in cvCrossManovaSearchlight (line 83)\ncm = CvCrossManova(Ys, Xs, analyses, fs=misc.fs, lambda=lambda);\n\n\nResults are written to files in the model directory. ccmsParameters.mat is a record of the analysis parameters and VPSL.nii is an image file where each voxel contains the number of voxels of the searchlight centered on it.\n\ndir(modelDir)\n\n\n.          ..         RPV.nii    ResMS.nii  SPM.mat    mask.nii   \n\n\n\nFiles with names of the form spmD_A####_P####.nii are images of pattern distinctness, i.e each voxel contains the estimated value of D from the voxels of the searchlight centered on it. The digits #### after A identify the analysis, and the digits after P the permutation (if no permutations were requested, only P0001 for the neutral permutation).\nWe visualize sagittal slices of spmD_A0001_P0001.nii, i.e. the actual pattern distinctness from the first analysis.\n\n% load data\n[D, XYZ] = spm_read_vols(spm_vol(fullfile(modelDir, 'spmD_A0001_P0001.nii')));\n% plot data\nfig = figure();\n% color map: parula, but black for NaN\ncm = parula();\ncm(1, :) = 0;\ncolormap(cm)\n% color limits from data\ncl = [min(D(:)), max(D(:))];\n% sagittal slices\nfig.Position(3:4) = [750, 1200];\ntiledlayout(8, 5, Padding=\"tight\", TileSpacing=\"tight\")\nfor i = 3 : 39\n    nexttile\n    slice = squeeze(D(i, :, :)) .'; \n    imagesc(slice)\n    clim(cl)\n    axis off image xy\nend\ncb = colorbar(Location='layout');\ncb.Layout.Tile = 40;\ncb.Label.String = 'D̂';\ncb.TickDirection = 'out';\n\nError using spm_vol&gt;spm_vol_hdr\nFile \"subj1/model/spmD_A0001_P0001.nii\" does not exist.\nError in spm_vol (line 61)\n        v = spm_vol_hdr(deblank(P(i,:)));\n\n\nThe largest values of D seem to be attained bilaterally in ventral temporal cortex, presumably the fusiform gyrus. Constrained (approximately) to the right and left hemispheres, the maximal values are:\n\nx = reshape(XYZ(1, :), size(D));\nDright = D .* (x &gt; 0);\nmaxDright = max(Dright(:))\nx = reshape(XYZ(1, :), size(D));\nDleft = D .* (x &lt; 0);\nmaxDleft = max(Dleft(:))\n\nUnrecognized function or variable 'XYZ'.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#interpretation-of-pattern-distinctness",
    "href": "tutorial-fmri-spm/cvmanova.html#interpretation-of-pattern-distinctness",
    "title": "Cross-validated MANOVA",
    "section": "Interpretation of pattern distinctness",
    "text": "Interpretation of pattern distinctness\nThe method of Cross-validated MANOVA estimates pattern distinctness D, which is defined as the amount of multivariate variance of the data explained by the effect encoded in the contrast, in units of the multivariate error variance. As such, D is a number larger or equal to zero, but without upper limit.\nIn the region-of-interest analyses above, we found a maximum value of D = 5.3228 for analysis 1 in region 1. This value is quite large, but it has to be interpreted relative to the contrast, which targeted the very broad ‘effect of category’ for both visually and semantically very different categories. Moreover, D accumulates across voxels (not exactly additively, but depending on the error correlation between voxels), and it is therefore larger for larger sets of voxels. In this case, region 1 (‘all ventral temporal object-selective cortex’) included 572 voxels. By comparison, the same analysis resulted in D = 0.36733 in the region 2 (‘region maximally responsive to faces’), which at 21 voxels is much smaller, and the searchlight of 123 voxels resulted in a maximum D of 2.1622.\nGiven that D is nonnegative, it may be surprising that the color bar for the slices from the searchlight analysis starts below zero, and indeed for analysis 1 D attained values from −0.1357 to 2.1622. The explanation is that the method can only provide a statistical estimate of D, more precisely denoted D̂. The estimator is designed to be unbiased, which means the estimates can be both larger and smaller than the actual value, and therefore an estimate can be negative if the actual value is close to zero. Such values should be disregarded since they can never be significantly different from zero.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvcrossmanova.html",
    "href": "tutorial-fmri-spm/cvcrossmanova.html",
    "title": "Cross-validated Cross-MANOVA",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% directory with estimated model\nmodelDir = fullfile(sub, 'model');\n\n\n8 contrasts between animate (“face”, “cat”) and inanimate objects (“bottle”, “scissors”, “shoe”, “chair”). Cross-MANOVA for all pairs of contrasts.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated Cross-MANOVA"
    ]
  },
  {
    "objectID": "tutorial-other/preparation.html",
    "href": "tutorial-other/preparation.html",
    "title": "Preparation",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% start from scratch\n[~] = rmdir(sub, 's');\n% URL for `1_P3_shifted_ds_reref_ucbip_hpfilt_ica_corr_cbip_elist_bins_epoch.set`\nsetURL = 'https://osf.io/download/d8yv4/';\n% URL for `1_P3_shifted_ds_reref_ucbip_hpfilt_ica_corr_cbip_elist_bins_epoch.fdt`\nfdtURL = 'https://osf.io/download/h4dtr/';",
    "crumbs": [
      "Tutorial: Other data",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-other/preparation.html#download-and-load-data",
    "href": "tutorial-other/preparation.html#download-and-load-data",
    "title": "Preparation",
    "section": "",
    "text": "% select subject\nsub = 'subj1';\n% start from scratch\n[~] = rmdir(sub, 's');\n% URL for `1_P3_shifted_ds_reref_ucbip_hpfilt_ica_corr_cbip_elist_bins_epoch.set`\nsetURL = 'https://osf.io/download/d8yv4/';\n% URL for `1_P3_shifted_ds_reref_ucbip_hpfilt_ica_corr_cbip_elist_bins_epoch.fdt`\nfdtURL = 'https://osf.io/download/h4dtr/';",
    "crumbs": [
      "Tutorial: Other data",
      "Preparation"
    ]
  }
]