[
  {
    "objectID": "example.html",
    "href": "example.html",
    "title": "Example analysis",
    "section": "",
    "text": "As an example for how to use the toolbox, here we apply Cross-validated MANOVA as well as Cross-validated Cross-MANOVA to the data of subject 1 from Haxby et al. (2001), downloaded from http://dev.pymvpa.org/datadb/haxby2001.html.\n\n% select subject\nsub = 'subj1';\n\nThe below computations are coded in such a way that already completed steps are not repeated, which is useful while making modifications. We here delete the subdirectory in which data and other information are kept to make sure all steps are performed.\n\n%rmdir(sub, 's')\n\nWe need SPM for preprocessing and defining a model:\n\nspm defaults fmri\nspm_jobman initcfg"
  },
  {
    "objectID": "example.html#introduction",
    "href": "example.html#introduction",
    "title": "Example analysis",
    "section": "",
    "text": "As an example for how to use the toolbox, here we apply Cross-validated MANOVA as well as Cross-validated Cross-MANOVA to the data of subject 1 from Haxby et al. (2001), downloaded from http://dev.pymvpa.org/datadb/haxby2001.html.\n\n% select subject\nsub = 'subj1';\n\nThe below computations are coded in such a way that already completed steps are not repeated, which is useful while making modifications. We here delete the subdirectory in which data and other information are kept to make sure all steps are performed.\n\n%rmdir(sub, 's')\n\nWe need SPM for preprocessing and defining a model:\n\nspm defaults fmri\nspm_jobman initcfg"
  },
  {
    "objectID": "example.html#preparation",
    "href": "example.html#preparation",
    "title": "Example analysis",
    "section": "Preparation",
    "text": "Preparation\nOpen the below boxes for the details of how data are downloaded, experimental design information is obtained, and BOLD images are realigned.\n\n\n\n\n\n\nDownload and unpack data\n\n\n\n\n\nThe data for the subject are downloaded as a .tar.gz archive, and the archive is unpacked.\n\n% make sure subdirectory with unpacked data is there\nif ~exist(sub, 'dir')\n    fn = [sub '-2010.01.14.tar.gz'];\n    url = ['http://data.pymvpa.org/datasets/haxby2001/' fn];\n\n    if ~exist(fn, 'file')\n        fprintf('  downloading %s\\n', fn)\n        urlwrite(url, fn);\n    end\n\n    fprintf('  unpacking %s\\n', fn)\n    untar(fn)\n    delete(fn)\nend\nfprintf('data has been downloaded and unpacked\\n')\n\ndata has been downloaded and unpacked\n\n\nMoreover, included NIfTI images are individually gzip-compressed and need to be decompressed.\n\n% make sure gunzipped BOLD data are there\nfnBOLD = [sub filesep 'bold.nii'];\nif ~exist(fnBOLD, 'file')\n    fprintf('  decompressing %s.gz\\n', fnBOLD)\n    gunzip([fnBOLD '.gz'])\n    delete([fnBOLD '.gz'])\nend\nfprintf('BOLD images have been decompressed\\n')\n\nBOLD images have been decompressed\n\n\n\n% make sure gunzipped region mask data are there\nfnRegions = {[sub filesep 'mask4_vt.nii'], ...\n             [sub filesep 'mask8_face_vt.nii'], ...\n             [sub filesep 'mask8_house_vt.nii']};\nfor i = 1 : numel(fnRegions)\n    if ~exist(fnRegions{i}, 'file')\n        fprintf('  decompressing %s.gz\\n', fnRegions{i})\n        gunzip([fnRegions{i} '.gz'])\n        delete([fnRegions{i} '.gz'])\n    end\nend\nfprintf('region mask images have been decompressed\\n')\n\nregion mask images have been decompressed\n\n\n\n\n\n\n\n\n\n\n\nObtain experimental design information\n\n\n\n\n\nInformation about the onsets and durations of stimuli in this subject are extracted from a file labels.txt. Other information is not included and has to be provided manually.\n\n% make sure design information is there\nfnDesign = [sub filesep 'design.mat'];\nif ~exist(fnDesign, 'file')\n    % design information which cannot be extracted\n    TR = 2.5;\n    nSessions = 12;\n    nVolsPerSession = 121;\n    conditions = [\"face\", \"house\", \"cat\", \"bottle\", ...\n        \"scissors\", \"shoe\", \"chair\", \"scrambledpix\"]; % + 'rest'\n\n    % extract stimulus information\n    fnLabels = [sub filesep 'labels.txt'];\n    fprintf('  extracting stimulus timing information from %s\\n', fnLabels)\n    % volume labels\n    labels = readtable(fnLabels, 'Delimiter', ' ');\n    %   sequence within session: (12 s rest, 24 s block) × 8, 12 s rest = 300 s\n    % extract condition for each block (from its middle)\n    nConds = numel(conditions);\n    [~, vsi] = ismember(labels{:, 1}, conditions);  % stimulus of volumes\n    vsi = reshape(vsi, nVolsPerSession, nSessions);\n    bsi = vsi(round((24 :36: 300) / TR) + 1, :);    % blocks × sessions\n    % prepare stimulus onset and duration information (in seconds)\n    %   each block has 12 stimulus presentations of the same condition\n    %   each stimulus was shown for 500 ms and was followed by a 1500 ms ISI\n    onsets = cell(nSessions, nConds);\n    durations = cell(nSessions, nConds);\n    for si = 1 : nSessions\n        for ci = 1 : nConds\n            % block in which condition is realized\n            bi = find(bsi(:, si) == ci);\n            % onset of block\n            bo = (bi - 1) * 36 + 12;\n            % onsets of stimuli in block\n            onsets{si, ci} = bo + (0 : 11) * 2;\n            durations{si, ci} = 0.5 * ones(1, 12);\n        end\n    end\n    % save design information\n    save(fnDesign, 'TR', 'nSessions', 'nVolsPerSession', ...\n        'conditions', 'nConds', 'onsets', 'durations')\nelse\n    % load design information\n    load(fnDesign)\nend\nfprintf('design information has been obtained\\n')\n\ndesign information has been obtained\n\n\n\n\n\n\n\n\n\n\n\nRealign BOLD data\n\n\n\n\n\n\n% make sure realigned BOLD data are there\nfnrBOLD = [sub filesep 'rbold.nii'];\nif ~exist(fnrBOLD, 'file')\n    fprintf('realigning volumes\\n')\n    matlabbatch = {};\n    for si = 1 : nSessions\n        vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);\n        vn = arrayfun(@(i) sprintf('%s,%d', fnBOLD, i), ...\n            vi, 'UniformOutput', false);\n        matlabbatch{1}.spm.spatial.realign.estwrite.data{si} = vn';\n    end\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.quality = 0.9;\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.sep = 4;\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.fwhm = 5;\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.rtm = 1;\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.interp = 2;\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.wrap = [0 0 0];\n    matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.weight = '';\n    matlabbatch{1}.spm.spatial.realign.estwrite.roptions.which = [2 1];\n    matlabbatch{1}.spm.spatial.realign.estwrite.roptions.interp = 4;\n    matlabbatch{1}.spm.spatial.realign.estwrite.roptions.wrap = [0 0 0];\n    matlabbatch{1}.spm.spatial.realign.estwrite.roptions.mask = 1;\n    matlabbatch{1}.spm.spatial.realign.estwrite.roptions.prefix = 'r';\n    spm_jobman('run', matlabbatch)\nend\nfprintf('BOLD data have been realigned\\n')\n\nBOLD data have been realigned"
  },
  {
    "objectID": "example.html#model-in-spm",
    "href": "example.html#model-in-spm",
    "title": "Example analysis",
    "section": "Model in SPM",
    "text": "Model in SPM\n\nDesign information\n\nfprintf('TR = %g [s]\\n', TR)\nfprintf('nSessions = %d\\n', nSessions)\nfprintf('nVolsPerSession = %d\\n', nVolsPerSession)\nfprintf('conditions = [\"%s\"]\\n', join(conditions, '\", \"'))\nfprintf('nConds = %d\\n', nConds)\n\nTR = 2.5 [s]\nnSessions = 12\nnVolsPerSession = 121\nconditions = [\"face\", \"house\", \"cat\", \"bottle\", \"scissors\", \"shoe\", \"chair\", \"scrambledpix\"]\nnConds = 8\n\n\nAdditionally, onsets and durations are cell arrays of size nSessions × nConds, where each cell contains a vector of stimulus onset times and durations in seconds.\nPlot stimulus onsets in each session:\n\n%plot -s 700,400\ncolors = [\"#0072BD\", \"#D95319\", \"#EDB120\", \"#7E2F8E\", ...\n    \"#77AC30\", \"#4DBEEE\", \"#A2142F\", \"#000000\"];\nfor ci = 1 : nConds\n    ons = [];\n    ses = [];\n    for si = 1 : nSessions\n        ons = [ons, onsets{si, ci}];\n        ses = [ses, si * ones(size(onsets{si, ci}))];\n    end\n    plot(ons, ses, '.', 'Color', colors(ci))\n    hold all\nend\nxlim([- TR , (nVolsPerSession + 1) * TR])\nylim([0.5, nSessions + 0.5])\nset(gca, 'YTick', 1 : nSessions)\nset(gca, 'YDir', 'reverse')\nylabel('session')\nxlabel('time / s')\nlegend(conditions, Location=\"eastoutside\")\n\n\n\n\n\n\nSpecify the model\n\n% make sure specified model is there\nmodelDir = [sub filesep 'model'];\nfnSPM = [modelDir filesep 'SPM.mat'];\nif ~exist(fnSPM, 'file')\n    fprintf('specifying model\\n')\n    load(fnDesign);\n    V = spm_vol(fnBOLD);    % for motion parameters\n    mat = cat(4, V.mat);\n    mkdir(modelDir)\n    fmri_spec = struct;\n    fmri_spec.dir = {modelDir};\n    fmri_spec.timing.units = 'secs';\n    fmri_spec.timing.RT = TR;\n    fmri_spec.timing.fmri_t = 25;\n    fmri_spec.timing.fmri_t0 = 12;\n    for si = 1 : nSessions\n        vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);\n        vn = arrayfun(@(i) sprintf('%s,%d', [pwd filesep fnrBOLD], i), ...\n            vi, 'UniformOutput', false);\n        Q = nan(nVolsPerSession, 6);\n        for i = 1 : nVolsPerSession\n            qq = spm_imatrix(mat(:, :, vi(i)) / mat(:, :, vi(1)));\n            Q(i, :) = qq(1 : 6);\n        end\n        fmri_spec.sess(si).scans = vn';\n        for ci = 1 : numel(conditions)\n            fmri_spec.sess(si).cond(ci).name = conditions{ci};\n            fmri_spec.sess(si).cond(ci).onset = onsets{si, ci};\n            fmri_spec.sess(si).cond(ci).duration = durations{si, ci};\n            fmri_spec.sess(si).cond(ci).tmod = 0;\n            fmri_spec.sess(si).cond(ci).orth = 1;\n        end\n        fmri_spec.sess(si).multi = {''};\n        for mi = 1 : 6\n            fmri_spec.sess(si).regress(mi).name = sprintf('motion%d', mi);\n            fmri_spec.sess(si).regress(mi).val = Q(:, mi);\n        end\n        fmri_spec.sess(si).multi_reg = {''};\n        fmri_spec.sess(si).hpf = 128;\n    end\n    fmri_spec.bases.hrf.derivs = [0 0];\n    fmri_spec.volt = 1;\n    fmri_spec.global = 'None';\n    fmri_spec.mthresh = 0.8;\n    fmri_spec.mask = {''};\n    fmri_spec.cvi = 'AR(1)';\n    matlabbatch = {};\n    matlabbatch{1}.spm.stats.fmri_spec = fmri_spec;\n    spm_jobman('run', matlabbatch(1))\nend\nfprintf('the model has been specified\\n')\n\nthe model has been specified\n\n\n\n\nEstimate the model\n\n% make sure estimated model is there\nif numel(dir([modelDir filesep 'beta_*.*'])) == 0\n    fprintf('estimating model\\n')\n    matlabbatch = {};\n    matlabbatch{1}.spm.stats.fmri_est.spmmat = {fnSPM};\n    matlabbatch{1}.spm.stats.fmri_est.write_residuals = 0;\n    matlabbatch{1}.spm.stats.fmri_est.method.Classical = 1;\n    spm_jobman('run', matlabbatch(1))\nend\nfprintf('the model has been estimated\\n')\n\nthe model has been estimated"
  },
  {
    "objectID": "example.html#references",
    "href": "example.html#references",
    "title": "Example analysis",
    "section": "References",
    "text": "References\n\n\nHaxby, J. V., Gobbini, M.  Ida., Furey, M. L., Ishai, A., Schouten, J. L., & Pietrini, P. (2001). Distributed and Overlapping Representations of Faces and Objects in Ventral Temporal Cortex. Science, 293, 2425–2430. https://doi.org/10.1126/science.1063736"
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Reference documentation",
    "section": "",
    "text": "data type representing an analysis\n\n\n\n\n\nCA\n‘training’ contrast, regressors × subcontrasts\n\n\nCB\n‘validation’ contrast, regressors × subcontrasts\n\n\nsessionsA\n‘training’ sessions, folds × sessions logical\n\n\nsessionsB\n‘validation’ sessions, folds × sessions logical\n\n\nL\nnumber of folds\n\n\nm\nnumber of sessions\n\n\nperms\nsign permutations, permutations × sessions\n\n\n\n\n\n\ncreate Analysis object for leave-one-session-out cross-validation\nanalysis = Analysis.leaveOneSessionOut(m, C)\nanalysis = Analysis.leaveOneSessionOut(m, CA, CB)\nThis is a convenience method which calls the constructor with sessionsB = logical(eye(m)) and sessionsA = not(sessionsB), the specification of standard leave-one-session-out cross-validation\nIf only one contrast C is specified, it is used for both ‘training’ (CA) and ‘validation’ (CB).\n\n\n\ncreate Analysis object\nanalysis = Analysis(CA, CB, sessionsA, sessionsB)\n\n\n\nadd sign permutations of per-session parameter estimates\nanalysis.addPermutations(maxPerms = 1000)\nThis method adds information to analysis that sign permutations should be applied, so that different values of D for the different permutations are computed.\n\n\n\n\n\n\nWarning\n\n\n\nSign permutations are used to test a per-subject null hypothesis of no effect in standard MANOVA analyses. It does not make sense to apply them to Cross-MANOVAs.\n\n\nFor m sessions there are formally 2m per-session sign permutations, but not all of them lead to different permutation values. The number of unique permutations depends on the ‘training’ and ‘validation’ sessions used in different folds (sessionsA, sessionsB). This method determines which permutations lead to different outcomes and makes sure only those unique permutations are performed.\nIf the number of unique permutations exceeds maxPerms, a randomly chosen subset of maxPerms is chosen (including the neutral permutation, which is always permutation 1).\n\n\n\ntextually display information about analysis\nanalysis.disp()\nThis method overrides Matlab’s disp, so you can also use disp(analysis) or simply analysis without semicolon to get the same output.\n\n\n\ngraphically display information about analysis\nfig = analysis.show()\nThe method creates a figure and returns the handle."
  },
  {
    "objectID": "reference.html#class-analysis",
    "href": "reference.html#class-analysis",
    "title": "Reference documentation",
    "section": "",
    "text": "data type representing an analysis\n\n\n\n\n\nCA\n‘training’ contrast, regressors × subcontrasts\n\n\nCB\n‘validation’ contrast, regressors × subcontrasts\n\n\nsessionsA\n‘training’ sessions, folds × sessions logical\n\n\nsessionsB\n‘validation’ sessions, folds × sessions logical\n\n\nL\nnumber of folds\n\n\nm\nnumber of sessions\n\n\nperms\nsign permutations, permutations × sessions\n\n\n\n\n\n\ncreate Analysis object for leave-one-session-out cross-validation\nanalysis = Analysis.leaveOneSessionOut(m, C)\nanalysis = Analysis.leaveOneSessionOut(m, CA, CB)\nThis is a convenience method which calls the constructor with sessionsB = logical(eye(m)) and sessionsA = not(sessionsB), the specification of standard leave-one-session-out cross-validation\nIf only one contrast C is specified, it is used for both ‘training’ (CA) and ‘validation’ (CB).\n\n\n\ncreate Analysis object\nanalysis = Analysis(CA, CB, sessionsA, sessionsB)\n\n\n\nadd sign permutations of per-session parameter estimates\nanalysis.addPermutations(maxPerms = 1000)\nThis method adds information to analysis that sign permutations should be applied, so that different values of D for the different permutations are computed.\n\n\n\n\n\n\nWarning\n\n\n\nSign permutations are used to test a per-subject null hypothesis of no effect in standard MANOVA analyses. It does not make sense to apply them to Cross-MANOVAs.\n\n\nFor m sessions there are formally 2m per-session sign permutations, but not all of them lead to different permutation values. The number of unique permutations depends on the ‘training’ and ‘validation’ sessions used in different folds (sessionsA, sessionsB). This method determines which permutations lead to different outcomes and makes sure only those unique permutations are performed.\nIf the number of unique permutations exceeds maxPerms, a randomly chosen subset of maxPerms is chosen (including the neutral permutation, which is always permutation 1).\n\n\n\ntextually display information about analysis\nanalysis.disp()\nThis method overrides Matlab’s disp, so you can also use disp(analysis) or simply analysis without semicolon to get the same output.\n\n\n\ngraphically display information about analysis\nfig = analysis.show()\nThe method creates a figure and returns the handle."
  },
  {
    "objectID": "reference.html#class-cvcrossmanova",
    "href": "reference.html#class-cvcrossmanova",
    "title": "Reference documentation",
    "section": "class CvCrossManova",
    "text": "class CvCrossManova\ndata type representing data and analyses\n\nproperties\n\n\n\nYs\ncell array of per-session design matrices, observations × variables\n\n\nXs\ncell array of per-session data matrices, observations × regressors\n\n\nanalyses\ncell array of Analysis objects\n\n\nlambda\nstrength of regularization (0–1) towards Euclidean metric\n\n\nfs\narray of per-session residual degrees of freedom\n\n\nm\nnumber of sessions\n\n\nns\narray of per-session numbers of observations (rows)\n\n\nnResults\narray of per-analysis returned numbers of results\n\n\n\n\n\nconstructor CvCrossManova\ncreate CvCrossManova object\nccm = CvCrossManova(Ys, Xs, analyses, lambda = 1e-8, fs = ...)\nA CvCrossManova object stores data matrices, design matrices, analysis definitions, and further parameters. Upon creation, it also estimates GLM parameters and errors. Actual analyses are then performed on subsets of variables by calling the method runAnalyses.\nThe parameter λ (from 0 to 1) controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix. A small value can be used to improve the numerical and statistical stability of the estimate; the default is 10−8. A value of 1 can be used to disregard the covariance structure, because it replaces the estimated error covariance matrix by a diagonal matrix where every diagonal element is the average variance across variables. This can be useful for Cross-MANOVA if it is intended to quantify orthogonality w.r.t the original data space (Euclidean metric) instead of the whitened space.\nIf the per-session residual degrees of freedom fs are not specified, they are calculated under the assumption that the data observations are uncorrelated, as ns(k) - rank(Xs{k}). If the observations have been only approximately decorrelated or have been filtered, correct values should be explicitly specified.\n\n\nmethod runAnalyses\nrun the defined analyses on (a subset of) the variables\nDs = ccm.runAnalyses(vi)\nDs = ccm.runAnalyses()\nvi specifies the variables to be included in the analysis, as column indices into the data matrices Ys. If omitted, all variables are included.\nDs is a cell array of analysis results where each element results from the corresponding element in analyses. Whether this result is an estimate of pattern distinctness D or pattern stability D× depends on the contrasts and regressors involved in them.\nFor an analysis which does not include permutations, the cell array element is a scalar; otherwise it is an array of permutation values, where the first element is the actual estimate (corresponding to the neutral permutation).\nTo determine how many values will be included in each of the elements of Ds before actually running an analysis, e.g. for preallocation, use the property nResults. It is a vector where each element gives the number of values returned for the corresponding analysis (i.e. the number of permutations).\n\n\nmethod dispAnalyses\ntextually display information about all analyses\nccm.dispAnalyses()\n\n\nmethod showAnalyses\ngraphically display information about all analyses\nccm.showAnalyses()\n\n\nmethod checkEstimability\ncheck estimability of all analyses’ contrasts in all sessions\n[estimability, problems] = ccm.checkEstimability()\nestimability is a table with one row per session and one column per analysis & contrast. ‘true’ means that the contrast is estimable, ‘false’ that it is not estimable, ‘–’ that the contrast does not apply to the session. The check is performed via the function contrastEstimable.\nproblems indicates whether there are any inestimable contrasts (logical).\nIt is not usually necessary to use this method explicitly, because estimability is checked upon creation of a CvCrossManova object."
  },
  {
    "objectID": "reference.html#function-cvcrossmanovasearchlight",
    "href": "reference.html#function-cvcrossmanovasearchlight",
    "title": "Reference documentation",
    "section": "function cvCrossManovaSearchlight",
    "text": "function cvCrossManovaSearchlight\ncross-validated (cross-) MANOVA on searchlight\ncvCrossManovaSearchlight(dirName, slRadius, Cs, permute = false, lambda = 0)\n\n\n\ndirName\ndirectory where the SPM.mat file referring to an estimated model is located\n\n\nslRadius\nradius of the searchlight sphere in voxels\n\n\nanalyses\ncell array of analysis specifications\n\n\npermute\nwhether to compute permutation values\n\n\nlambda\nregularization parameter (0–1)\n\n\n\nOutput files are written to the same directory:\n\n\n\nspmD_C####_P####.nii\nimages of the pattern discriminability D, contrast and permutation are identified by numbers\n\n\nspmDs_C####_P####.nii\nimages of standardized pattern discriminability Ds\n\n\nVPSL.nii\nimage of the number of voxels for each searchlight\n\n\ncmsParameters.mat\nrecord of the analysis parameters"
  },
  {
    "objectID": "reference.html#function-cvcrossmanovaregion",
    "href": "reference.html#function-cvcrossmanovaregion",
    "title": "Reference documentation",
    "section": "function cvCrossManovaRegion",
    "text": "function cvCrossManovaRegion\ncross-validated MANOVA on region\n[D, p] = cvCrossManovaRegion(dirName, regions, analyses, permute = false, lambda = 0)\n\n\n\ndirName\ndirectory where the SPM.mat file referring to an estimated model is located\n\n\nregions\nregion mask(s), (cell array of) logical 3D volume(s) or filename(s)\n\n\nanalyses\ncell array of analysis specifications\n\n\nlambda\nregularization parameter (0–1)\n\n\npermute\nwhether to compute permutation values\n\n\nD\npattern distinctness, contrasts × permutations × regions\n\n\np\nnumber of voxels in the region(s)"
  },
  {
    "objectID": "reference.html#function-contrastestimable",
    "href": "reference.html#function-contrastestimable",
    "title": "Reference documentation",
    "section": "function contrastEstimable",
    "text": "function contrastEstimable\ncheck whether a contrast is estimable w.r.t. a design matrix\n[estimable, error] = contrastEstimable(C, X)\ncontrastEstimable(C, X)\n\n\n\nC\ncontrast matrix, regressors × subcontrasts\n\n\nX\ndesign matrix, observations × regressors\n\n\nestimable\nwhether the contrast is estimable, logical\n\n\nerror\ndegree of inestimability\n\n\n\nEstimability is determined by checking whether the contrast is contained in the row space of the design matrix (see Friston et al. 2007, p. 106). error is the underlying numerical measure of inestimability, which should be 0 for an estimable contrast, but may just be close to 0 due to numerical error. The criterion used is estimable = (error &lt; max(size(C)) * eps).\nThe second syntax reports the result instead of returning it."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MVPA by Cross-Validated (Cross-) MANOVA",
    "section": "",
    "text": "This project is under development and not yet usable.\nThis software is copyrighted © 2023 by Carsten Allefeld and released under the terms of the GNU General Public License, version 3 or later. Remi Gau, Polina Iamshchinina, and Thomas Christophel contributed to the code.\nIt has been developed with Matlab R2023a (v9.14) and SPM12 r7771, but should work with later and slightly earlier versions.\nThe software does not depend on other toolboxes, except cvCrossManovaRegion and cvCrossManovaSearchlight which depend on SPM12 being installed."
  }
]