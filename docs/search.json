[
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "API Reference documentation",
    "section": "",
    "text": "The CvCrossManova toolbox has two interfaces to perform analyses:\nA simplified interface to analyse fMRI data which have been modeled in SPM is provided by the functions ccmRegion for region-of-interest analyses and ccmSearchlight for searchlight analyses. Both functions take a parameter analyses which is a cell array of Analysis objects specifying analyses.\nA more complex but also more versatile interface, which can be used with arbitrary suitable data, is provided by objects of class CvCrossManova. Upon creation, a ModeledData object containing data and design matrices as well as an analyses cell array have to be provided. After that, analyses can be run on subsets of dependent variables using the method runAnalyses.\n\n\n\nThe CvCrossManova toolbox implements both Cross-validated MANOVA resulting in pattern distinctness D and Cross-validated (Cross-) MANOVA resulting in pattern stability D×. Which of these a given Analysis specification corresponds to depends on the contrast matrices and the regressors involved in them.\nIn the simplest case where a regressor has the same meaning (corresponds to the same experimental condition) in all sessions (the same set of regressors is present in all sessions in the same order), Cross-validated MANOVA uses a single contrast matrix, which is used for both ‘training’ (CA) and ‘validation’ (CB), and Cross-validated Cross-MANOVA uses two different contrast matrices. However, if e.g. some experimental events occur only in some sessions and the corresponding regressors therefore do not occur in the others, it may happen that two different contrast matrices are necessary for Cross-validated MANOVA and the that a single contrast matrix can be used for Cross-validated Cross-MANOVA.\n\n\n\n\n\n\nTip\n\n\n\nIt is recommended to always include all regressors in all sessions, even if they may be empty in some of them. This will lead to the corresponding parameter to be inestimable in those sessions, but as long as the contrasts used are estimable, this is not a problem for the analysis.\n\n\n\n\n\nThe numerical parameter radius of ccmSearchlight specifies the radius of the searchlight sphere in voxels.\n\n\n\n\n\n\nCaution\n\n\n\nNote that a voxel is included in a searchlight if its distance from the center voxel is smaller than or equal to the radius. This convention may be different from the one used by other software packages.\n\n\nNote also that fractional values of radius are possible and meaningful:\n\n\n\n\n\n\n\n\n\nradius\npMax\n\n\n\n\n0\n1\n\n\n1\n7\n\n\n1.5\n19\n\n\n1.8\n27\n\n\n2\n33\n\n\n2.3\n57\n\n\n2.5\n81\n\n\n2.9\n93\n\n\n3\n123\n\n\n3.2\n147\n\n\n3.4\n171\n\n\n\n\n\n\n\n\nradius\npMax\n\n\n\n\n3.5\n179\n\n\n3.7\n203\n\n\n3.8\n251\n\n\n4\n257\n\n\n4.2\n305\n\n\n4.3\n341\n\n\n4.4\n365\n\n\n4.5\n389\n\n\n4.6\n437\n\n\n4.7\n461\n\n\n4.9\n485\n\n\n\n\n\n\n\n\nradius\npMax\n\n\n\n\n5\n515\n\n\n5.1\n587\n\n\n5.2\n619\n\n\n5.4\n691\n\n\n5.5\n739\n\n\n5.7\n751\n\n\n5.8\n799\n\n\n5.9\n847\n\n\n5.92\n895\n\n\n6\n925\n\n\n6.1\n949\n\n\n\n\n\n\npMax is the maximum number of voxels, which is reached by a searchlight completely within the brain mask; at its boundaries the actual number will be smaller.\n\n\n\nanalysis.addPermutations adds information to an Analysis object that permutations should be applied, so that subsequent analysis runs return not just the actual estimate but also permutation values, which can be used for a permutation test.\nThe ‘permutation’ method implemented is to switch the sign (±) of GLM parameter estimates in each session separately, as proposed by Allefeld & Haynes (2014). For m sessions there are formally 2m per-session sign permutations, but not all of them lead to different permutation values of D; the number of unique permutations depends on the ‘training’ and ‘validation’ sessions used in different folds. addPermutations determines which permutations can lead to different outcomes and makes sure only those unique permutations are included.\n\n\n\n\n\n\nCaution\n\n\n\nSign permutations are used to test a per-unit (e.g. participant) null hypothesis of no effect in Cross-validated MANOVA analyses resulting in estimates of D. It does not make sense to apply them to Cross-MANOVA analyses resulting in estimates of D×.\n\n\nIf the number of unique permutations is too large, a maximum number of permutations to be applied can be specified via the parameter maxPerms. In that case, a random subset of permutations is chosen which can be used for a Monte-Carlo permutation test (Dwass, 1957).\n\n\n\n\n\n\nTip\n\n\n\nNote that if the permutations are chosen randomly, the result of the permutation test is in principle random, too. To ensure reproducible results, it is recommended to run s = rng('shuffle') once, note the values of s.Seed and s.Type, and then to include rng(&lt;Seed&gt;, &lt;Type&gt;) in your analysis pipeline. This is also necessary for the checkpointing mechanism in ccmSearchlight to be effective.\n\n\nIf permutations are applied, an analysis which would normally return a single value (the actual estimate) instead returns an array of permutation values. Permutations always include the neutral permutation which does not modify the data, and it is always permutation 1, i.e. the actual estimate is always the first in an array of permutation values.\nNote that the toolbox does not implement the actual permutation test. For a single unit (participant), a permutation test can be implemented by comparing the actual value with all permutation values (including the actual value resulting from the neutral permutation) and rejecting the null hypothesis at significance level α if the actual value ranks within the upper α-quantile. A simple implementation is pvalue = mean(D &gt;= D(1)). See Ernst (2004) for details, including how to correct for multiple comparisons. For permutation-based population inference for MVPA, see Allefeld et al. (2016).\n\n\n\nThe logical parameter wf of ccmRegion, ccmSearchlight, and ModeledData.fromSPM specifies whether to apply the whitening and high-pass filtering (set up in SPM) to data and design matrices. The default value is true.\n\n\n\n\n\n\nCaution\n\n\n\nIt is recommended to keep the default value. While the pattern distinctness and pattern stability estimators should still be unbiased because the residual degrees of freedom are adjusted, not whitening will lead to decreased precision and not filtering will retain low-frequency signal components which may act as a confound for experimental effects.\n\n\n\n\n\nThe numerical parameter lambda (from 0 to 1) of ccmRegion, ccmSearchlight, and CvCrossManova controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix, which improves the numerical and statistical stability of the estimates of D and D×. A drawback of regularization is that with it this estimation is no longer unbiased. The small default value of 10−8 was chosen to limit this effect while still providing somewhat improved numerical stability.\nA larger value may be necessary if a larger number of dependent variables (voxels) enter an analysis. While there are approaches to determine the optimal amount of shrinkage regularization from the data (cf. Schäfer & Strimmer, 2005), in our experience they are not sufficiently reliable to be applied automatically.\n\n\n\n\n\n\nTip\n\n\n\nIt is recommended to usually keep the default value and rather restrict the number of dependent variables (voxels) analyzed together. If that is not possible, one pragmatic approach would be to manually optimize lambda on one unit (e.g. participant) which is then not used for further analysis.\n\n\nThe target of the shrinkage regularization is the diagonal matrix where every diagonal element is identical to the error variance averaged across dependent variables. A lambda value of 1 can therefore be used to disregard the error covariance structure, because it replaces the estimated error covariance matrix by this shrinkage target. This can be useful for Cross-MANOVA if it is intended to quantify orthogonality w.r.t. the original data space (Euclidean metric) instead of the whitened space.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#general-notes",
    "href": "reference.html#general-notes",
    "title": "API Reference documentation",
    "section": "",
    "text": "The CvCrossManova toolbox has two interfaces to perform analyses:\nA simplified interface to analyse fMRI data which have been modeled in SPM is provided by the functions ccmRegion for region-of-interest analyses and ccmSearchlight for searchlight analyses. Both functions take a parameter analyses which is a cell array of Analysis objects specifying analyses.\nA more complex but also more versatile interface, which can be used with arbitrary suitable data, is provided by objects of class CvCrossManova. Upon creation, a ModeledData object containing data and design matrices as well as an analyses cell array have to be provided. After that, analyses can be run on subsets of dependent variables using the method runAnalyses.\n\n\n\nThe CvCrossManova toolbox implements both Cross-validated MANOVA resulting in pattern distinctness D and Cross-validated (Cross-) MANOVA resulting in pattern stability D×. Which of these a given Analysis specification corresponds to depends on the contrast matrices and the regressors involved in them.\nIn the simplest case where a regressor has the same meaning (corresponds to the same experimental condition) in all sessions (the same set of regressors is present in all sessions in the same order), Cross-validated MANOVA uses a single contrast matrix, which is used for both ‘training’ (CA) and ‘validation’ (CB), and Cross-validated Cross-MANOVA uses two different contrast matrices. However, if e.g. some experimental events occur only in some sessions and the corresponding regressors therefore do not occur in the others, it may happen that two different contrast matrices are necessary for Cross-validated MANOVA and the that a single contrast matrix can be used for Cross-validated Cross-MANOVA.\n\n\n\n\n\n\nTip\n\n\n\nIt is recommended to always include all regressors in all sessions, even if they may be empty in some of them. This will lead to the corresponding parameter to be inestimable in those sessions, but as long as the contrasts used are estimable, this is not a problem for the analysis.\n\n\n\n\n\nThe numerical parameter radius of ccmSearchlight specifies the radius of the searchlight sphere in voxels.\n\n\n\n\n\n\nCaution\n\n\n\nNote that a voxel is included in a searchlight if its distance from the center voxel is smaller than or equal to the radius. This convention may be different from the one used by other software packages.\n\n\nNote also that fractional values of radius are possible and meaningful:\n\n\n\n\n\n\n\n\n\nradius\npMax\n\n\n\n\n0\n1\n\n\n1\n7\n\n\n1.5\n19\n\n\n1.8\n27\n\n\n2\n33\n\n\n2.3\n57\n\n\n2.5\n81\n\n\n2.9\n93\n\n\n3\n123\n\n\n3.2\n147\n\n\n3.4\n171\n\n\n\n\n\n\n\n\nradius\npMax\n\n\n\n\n3.5\n179\n\n\n3.7\n203\n\n\n3.8\n251\n\n\n4\n257\n\n\n4.2\n305\n\n\n4.3\n341\n\n\n4.4\n365\n\n\n4.5\n389\n\n\n4.6\n437\n\n\n4.7\n461\n\n\n4.9\n485\n\n\n\n\n\n\n\n\nradius\npMax\n\n\n\n\n5\n515\n\n\n5.1\n587\n\n\n5.2\n619\n\n\n5.4\n691\n\n\n5.5\n739\n\n\n5.7\n751\n\n\n5.8\n799\n\n\n5.9\n847\n\n\n5.92\n895\n\n\n6\n925\n\n\n6.1\n949\n\n\n\n\n\n\npMax is the maximum number of voxels, which is reached by a searchlight completely within the brain mask; at its boundaries the actual number will be smaller.\n\n\n\nanalysis.addPermutations adds information to an Analysis object that permutations should be applied, so that subsequent analysis runs return not just the actual estimate but also permutation values, which can be used for a permutation test.\nThe ‘permutation’ method implemented is to switch the sign (±) of GLM parameter estimates in each session separately, as proposed by Allefeld & Haynes (2014). For m sessions there are formally 2m per-session sign permutations, but not all of them lead to different permutation values of D; the number of unique permutations depends on the ‘training’ and ‘validation’ sessions used in different folds. addPermutations determines which permutations can lead to different outcomes and makes sure only those unique permutations are included.\n\n\n\n\n\n\nCaution\n\n\n\nSign permutations are used to test a per-unit (e.g. participant) null hypothesis of no effect in Cross-validated MANOVA analyses resulting in estimates of D. It does not make sense to apply them to Cross-MANOVA analyses resulting in estimates of D×.\n\n\nIf the number of unique permutations is too large, a maximum number of permutations to be applied can be specified via the parameter maxPerms. In that case, a random subset of permutations is chosen which can be used for a Monte-Carlo permutation test (Dwass, 1957).\n\n\n\n\n\n\nTip\n\n\n\nNote that if the permutations are chosen randomly, the result of the permutation test is in principle random, too. To ensure reproducible results, it is recommended to run s = rng('shuffle') once, note the values of s.Seed and s.Type, and then to include rng(&lt;Seed&gt;, &lt;Type&gt;) in your analysis pipeline. This is also necessary for the checkpointing mechanism in ccmSearchlight to be effective.\n\n\nIf permutations are applied, an analysis which would normally return a single value (the actual estimate) instead returns an array of permutation values. Permutations always include the neutral permutation which does not modify the data, and it is always permutation 1, i.e. the actual estimate is always the first in an array of permutation values.\nNote that the toolbox does not implement the actual permutation test. For a single unit (participant), a permutation test can be implemented by comparing the actual value with all permutation values (including the actual value resulting from the neutral permutation) and rejecting the null hypothesis at significance level α if the actual value ranks within the upper α-quantile. A simple implementation is pvalue = mean(D &gt;= D(1)). See Ernst (2004) for details, including how to correct for multiple comparisons. For permutation-based population inference for MVPA, see Allefeld et al. (2016).\n\n\n\nThe logical parameter wf of ccmRegion, ccmSearchlight, and ModeledData.fromSPM specifies whether to apply the whitening and high-pass filtering (set up in SPM) to data and design matrices. The default value is true.\n\n\n\n\n\n\nCaution\n\n\n\nIt is recommended to keep the default value. While the pattern distinctness and pattern stability estimators should still be unbiased because the residual degrees of freedom are adjusted, not whitening will lead to decreased precision and not filtering will retain low-frequency signal components which may act as a confound for experimental effects.\n\n\n\n\n\nThe numerical parameter lambda (from 0 to 1) of ccmRegion, ccmSearchlight, and CvCrossManova controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix, which improves the numerical and statistical stability of the estimates of D and D×. A drawback of regularization is that with it this estimation is no longer unbiased. The small default value of 10−8 was chosen to limit this effect while still providing somewhat improved numerical stability.\nA larger value may be necessary if a larger number of dependent variables (voxels) enter an analysis. While there are approaches to determine the optimal amount of shrinkage regularization from the data (cf. Schäfer & Strimmer, 2005), in our experience they are not sufficiently reliable to be applied automatically.\n\n\n\n\n\n\nTip\n\n\n\nIt is recommended to usually keep the default value and rather restrict the number of dependent variables (voxels) analyzed together. If that is not possible, one pragmatic approach would be to manually optimize lambda on one unit (e.g. participant) which is then not used for further analysis.\n\n\nThe target of the shrinkage regularization is the diagonal matrix where every diagonal element is identical to the error variance averaged across dependent variables. A lambda value of 1 can therefore be used to disregard the error covariance structure, because it replaces the estimated error covariance matrix by this shrinkage target. This can be useful for Cross-MANOVA if it is intended to quantify orthogonality w.r.t. the original data space (Euclidean metric) instead of the whitened space.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#ccmregion",
    "href": "reference.html#ccmregion",
    "title": "API Reference documentation",
    "section": "function ccmRegion",
    "text": "function ccmRegion\nrun Cross-validated (Cross-) MANOVA on regions\n[Ds, ps] = ccmRegion(modelDir, regions, analyses, wf = true, lambda = 1e-8)\nmodelDir is the directory where the SPM.mat file referring to an estimated model is located.\nregions is a cell array of logical 3D volumes or filenames specifying region masks. Without it, only the SPM brain mask is applied.\nanalyses is a cell array of Analysis objects specifying analyses.\nThe optional wf specifies whether to apply whitening and high-pass filtering (set up in SPM) to data and design matrices. It should usually be kept at its default value.\nThe optional lambda (from 0 to 1) controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix. It should usually be kept at its default value.\nDs is a two-dimensional cell array of analysis results where each cell corresponds to the combination of an analysis (rows) and a region (columns).\nWhether a result is an estimate of pattern distinctness D or pattern stability D× depends on the contrasts of the corresponding analysis and the regressors involved in them.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#ccmsearchlight",
    "href": "reference.html#ccmsearchlight",
    "title": "API Reference documentation",
    "section": "function ccmSearchlight",
    "text": "function ccmSearchlight\nrun Cross-validated (Cross-) MANOVA on searchlight\nccmSearchlight(modelDir, radius, analyses, wf = true, lambda = 1e-8)\nmodelDir is the directory where the SPM.mat file referring to an estimated model is located.\nradius is the radius of the searchlight sphere in voxels.\nanalyses is a cell array of Analysis objects specifying analyses.\nThe optional wf specifies whether to apply whitening and high-pass filtering (set up in SPM) to data and design matrices. It should usually be kept at its default value.\nThe optional lambda (from 0 to 1) controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix. It should usually be kept at its default value.\nAnalysis results are written to image files the same directory modelDir, with names of the form spmD_A####_P####.nii. The number following A indicates the analysis and the number following P indicates the permutation.\nWhether a result is an estimate of pattern distinctness D or pattern stability D× depends on the contrasts of the corresponding analysis and the regressors involved in them.\nIn addition, an image file VPSL.nii is written containing the numbers of voxels for each searchlight, and a Matlab file ccmSearchlightParams.mat is written containing a record of the analysis parameters.\nThe searchlight procedure includes a checkpointing mechanism: Intermediate results are saved to a file ccmsCheckpoint….mat, where … stands for a 32-digit hexadecimal checksum of the analysis parameters. If a run of ccmSearchlight is interrupted, running it again recovers partial results from the checkpoint file and continues from there.\nNote that checkpointing only works if all analysis parameters remain identical. In particular, if the analysis includes randomly selected permutations, make sure to initialize Matlab’s random number generator before the selection.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#analysis",
    "href": "reference.html#analysis",
    "title": "API Reference documentation",
    "section": "class Analysis",
    "text": "class Analysis\nAn Analysis object encapsulates ‘training’ and ‘validation’ contrasts and sessions as well as permutations, which together specify a Cross-validated (Cross-) MANOVA analysis.\n\nproperties\n\n\n\nCA\n‘training’ contrast matrix, regressors × subcontrasts\n\n\nCB\n‘validation’ contrast matrix, regressors × subcontrasts\n\n\nsessionsA\n‘training’ sessions logical matrix, folds × sessions\n\n\nsessionsB\n‘validation’ sessions logical matrix, folds × sessions\n\n\nL\nnumber of folds\n\n\nm\nnumber of sessions\n\n\nperms\nsign permutations, permutations × sessions\n\n\n\n\n\nconstructor Analysis\ncreate Analysis object\nanalysis = Analysis(CA, CB, sessionsA, sessionsB)\nCA and CB are ‘training’ and ‘validation’ contrast matrices, respectively.\nsessionsA and sessionsB are logical matrices which indicate which sessions (columns) are used for ‘training’ and ‘validation’, respectively, in each fold (rows).\n\n\nstatic method leaveOneSessionOut\ncreate Analysis object for leave-one-session-out cross-validation\nanalysis = Analysis.leaveOneSessionOut(m, CA, CB)\nanalysis = Analysis.leaveOneSessionOut(m, C)\nm is the number of sessions. The object is created with ‘training’ sessions not(logical(eye(m))) and ‘validation’ sessions logical(eye(m)), the specification of standard leave-one-session-out cross-validation.\nCA and CB are ‘training’ and ‘validation’ contrast matrices, respectively. If only one contrast matrix C is specified, it is used for both.\n\n\nmethod addPermutations\nadd sign permutations of per-session parameter estimates\nanalysis.addPermutations(maxPerms = 1000)\nThis method adds information to analysis that sign permutations should be applied, so that different values of pattern distinctness D for the different permutations are computed.\nThe optional maxPerms specifies the maximum number of permutations.\n\n\nmethod disp\ntextually display information about the object\nanalysis.disp()\nThis method overrides Matlab’s disp, so you can also use disp(analysis) or simply analysis without semicolon to get the same output.\n\n\nmethod show\ngraphically display information about the object\nfig = analysis.show()\nThis method creates a figure showing contrast matrices, session matrices, and if present permutations.\nfig is the handle of the created figure.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#modeleddata",
    "href": "reference.html#modeleddata",
    "title": "API Reference documentation",
    "section": "class ModeledData",
    "text": "class ModeledData\nA ModeledData object encapsulates data and design matrices for multiple sessions along with supplementary information. Upon creation, it estimates and stores GLM parameters and errors. Combined with one or more Analysis objects, it is the basis for analyses within a CvCrossManova object.\n\nproperties\n\n\n\nXs\ncell array of per-session data matrices, observations × independent variables\n\n\nYs\ncell array of per-session design matrices, observations × dependent variables\n\n\nfs\narray of per-session residual degrees of freedom\n\n\nm\nnumber of sessions\n\n\nns\narray of per-session numbers of observations\n\n\np\nnumber of dependent variables\n\n\nqs\narray of per-session numbers of independent variables\n\n\nnames\ncell array of per-session string arrays of names of independent variables\n\n\n\n\n\nconstructor ModeledData\ncreate ModeledData object\nmodeledData = ModeledData(Ys, Xs, fs = ..., names = ...)\nYs and Xs are cell arrays of per-session data and design matrices, respectively.\nThe optional fs is an array of per-session residual degrees of freedom. Their default values are size(Xs{k}, 1) - rank(Xs{k}), corresponding to the assumption that observations are uncorrelated. If observations have been only approximately decorrelated or have been filtered, correct values should be explicitly specified.\nThe optional names is a cell array of per-session string arrays of names of independent variables. Default names are identical in all sessions and of the form \"reg(#)\", where # is the index of the independent variable. If independent variables with the same index in different sessions have different meanings, correct names should be explicitly specified.\n\n\nstatic method fromSPM\ncreate ModeledData object from SPM data\n[modeledData, misc] = fromSPM(modelDir, regions = {}, wf = true)\nmodelDir is the directory where the SPM.mat file referring to an estimated model is located.\nThe optional regions is a cell array of logical 3D volumes or filenames specifying region masks. Without it, only the SPM brain mask is applied.\nThe optional wf specifies whether to apply whitening and high-pass filtering (set up in SPM) to data and design matrices. It should usually be kept at its default value.\nDependent variables (columns of data matrices Ys) are only read from voxels within the SPM analysis brain mask after it was intersected with the union of region masks (if provided).\nmisc is a structure of fields containing additional information:\n\n\n\nmask\nlogical 3D volume indicating the voxels which dependent variables correspond to\n\n\nmat\n3D voxel indices to mm transformation matrix\n\n\nrmvi\nindices of dependent variables corresponding to each region, cell array of arrays\n\n\n\n\n\nmethod disp\ntextually display information about the object\nmodeledData.disp()\nThis method overrides Matlab’s disp, so you can also use disp(modeledData) or simply modeledData without semicolon to get the same output.\n\n\nmethod show\ngraphically display information about the object\nfig = analysis.show(rescale = true)\nThis method creates a figure showing the design matrices of all sessions.\nThe optional rescale specifies whether independent variables are individually rescaled to an absolute maximum of 1, to aid visibility of details.\nfig is the handle of the created figure.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "reference.html#cvcrossmanova",
    "href": "reference.html#cvcrossmanova",
    "title": "API Reference documentation",
    "section": "class CvCrossManova",
    "text": "class CvCrossManova\nA CvCrossManova object implements the Cross-validated (Cross-) MANOVA algorithm. It combines the data and design matrices encapsulated in a ModeledData object with the analysis specifications of one or more Analysis objects. If its method runAnalyses is called for a set of dependent variables, all specified analyses are performed on these variables concurrently. This enables a more efficient implementation of the algorithm, because partial results shared between analyses only have to be computed once.\n\nproperties\n\n\n\nmodeledData\ndata and design information, ModeledData object\n\n\nanalyses\nanalysis specifications, cell array of Analysis objects\n\n\nlambda\namount of shrinkage regularization\n\n\nnAnalyses\nnumber of analyses\n\n\n\n\n\nconstructor CvCrossManova\ncreate CvCrossManova object\nccm = CvCrossManova(modeledData, analyses, lambda = 1e-8)\nmodeledData is a ModeledData object encapsulating data and design matrices for multiple sessions.\nanalyses is a cell array of Analysis objects specifying analyses.\nThe optional lambda (from 0 to 1) controls the amount of shrinkage regularization applied to the estimate of the error covariance matrix. It should usually be kept at its default value.\n\n\nmethod runAnalyses\nrun analyses on (a subset of) the dependent variables\nDs = ccm.runAnalyses(vi)\nDs = ccm.runAnalyses()\nvi specifies the variables to be included in the analysis, as column indices into the data matrices Ys of modeledData. If omitted, all variables are included.\nDs is a cell array of analysis results where each cell corresponds to a cell of analyses, either a scalar value or an array of permutation values.\nWhether a result is an estimate of pattern distinctness D or pattern stability D× depends on the contrasts of the corresponding analysis and the regressors involved in them.\nTo determine how many values will be included in each of the cells of Ds before actually running the analyses, e.g. for preallocation, use the method nResults.\n\n\nmethod nResults\nreturn the number of values returned by runAnalyses\nnr = ccm.nResults()\nnr is an array where each element corresponds to an analysis, and the value specifies the number of results returned for that analysis. For an analysis without permutations, that value is 1; otherwise it is the number of permutations.\n\n\nmethod checkEstimability\ncheck estimability of all contrasts of all analyses in all sessions\n[estimability, problems] = ccm.checkEstimability()\nestimability is a table with one row per session and one column per analysis & contrast. ‘true’ means that the contrast is estimable, ‘false’ that it is not estimable, ‘–’ that the contrast does not apply to the session. The check is performed via the function contrastEstimable.\nproblems indicates whether there are any inestimable contrasts (logical).\nIt is not usually necessary to use this method explicitly, because estimability is checked upon creation of a CvCrossManova object.\n\n\nmethod disp\ntextually display information about the object\nccm.disp()\nThis method overrides Matlab’s disp, so you can also use disp(ccm) or simply ccm without semicolon to get the same output.",
    "crumbs": [
      "API Reference documentation"
    ]
  },
  {
    "objectID": "tutorial-other/index.html",
    "href": "tutorial-other/index.html",
    "title": "Tutorial: Other data",
    "section": "",
    "text": "As an example for how to use the toolbox to analyze data other than fMRI, here we apply Cross-validated MANOVA as well as Cross-validated Cross-MANOVA to data from Kappenman et al. (2021). Their ERP CORE resource provides experimental material and data from paradigms eliciting seven standard ERP components.\nIn particular, we use the data of subject 1 from their P3 paradigm. In the Supplementary Materials the authors write:\n\nThe P3 was elicited in an active visual oddball paradigm. […] On each trial, one of five uppercase letters (A, B, C, D, or E […]) was presented for 200 ms in the center of the screen over the fixation point. […] Participants completed a total of 200 trials, divided into five blocks of 40 trials each. In each block, one letter was designated the target stimulus and the other four letters were designated non-targets. Participants pressed one button for targets and another button for non-targets. Each of the five letters served as a target in one block of the experiment and as a non-target in the other four blocks, with the order of blocks randomized across participants. Each letter was presented with equal probability within a block of trials (p = .2), such that the target category was rare (p = .2) and the non-target category was frequent (p = .8).\n\nThe analysis is broken down into several steps in the following subpages:\n\n\n\n\n\n\n\n\n\n\n\nPreparation\n\n\nData are downloaded and design information extracted\n\n\n\n\n\n\n\n\n\n\nNo matching items\n\nReferences\n\nKappenman, E. S., Farrens, J. L., Zhang, W., Stewart, A. X., & Luck, S. J. (2021). ERP CORE: An open resource for human event-related potential research. NeuroImage, 225, 117465. https://doi.org/10.1016/j.neuroimage.2020.117465",
    "crumbs": [
      "Tutorial: Other data"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html",
    "href": "tutorial-fmri-spm/pairwise.html",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "",
    "text": "Matlab script\n\n\n\ndownload\n% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% directory with estimated model\nmodelDir = fullfile(sub, 'model');",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html#define-contrasts-and-analyses",
    "href": "tutorial-fmri-spm/pairwise.html#define-contrasts-and-analyses",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "Define contrasts and analyses",
    "text": "Define contrasts and analyses\nHaxby et al. used a pairwise correlation-based classifier applied to parameter estimates for each condition, estimated across even and odd sessions, respectively.\nCross-validated MANOVA replaces accuracy based on classification by explained multivariate variance based on contrasts. The equivalent of pairwise classification is a contrast with a 1 for one of the two categories, a −1 for the other, and zeros otherwise. We construct these 28 contrasts, and then analyses based on them using two folds, odd → even and even → odd:\n\n% construct pairwise contrasts and analyses\nanalyses = cell(nConds, nConds);\nodd = (mod(1 : nSessions, 2) == 1);\neven = (mod(1 : nSessions, 2) == 0);\nfor i = 1 : nConds\n    for j = i + 1 : nConds\n        C = zeros(nConds, 1);\n        C([i, j]) = [1, -1];\n        analyses{i, j} = Analysis(C, C, [odd ; even], [even ; odd]);\n    end\nend\n% reduce to defined analyses\nind = find(~cellfun(@isempty, analyses)) .';\nanalyses = analyses(ind);\n\nFor illustration, analysis #12 has this structure:\n\nanalyses{12}.show()",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html#run-analyses-on-region-of-interest",
    "href": "tutorial-fmri-spm/pairwise.html#run-analyses-on-region-of-interest",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "Run analyses on region of interest",
    "text": "Run analyses on region of interest\nHaxby et al. applied their analysis to several regions of interest. The data available to us contain masks for three regions, of which we here use the first.\n\n[Ds, ps] = ccmRegion(modelDir, regions(1), analyses);\n\n\nccmRegion\n\nloading data via subj1/model/SPM.mat\n  volume of 40 × 64 × 64 = 163840 voxels\n  27638 voxels within brain mask\n    572 voxels within brain mask in subj1/mask4_vt.nii\n  572 voxels within brain mask in all regions\n  reading images from subj1/rbold.nii,????\n  1452 of 1452 volumes loaded\n  whitening\n  high-pass-filtering\n\ncomputing Cross-validated (Cross-) MANOVA\n  CvCrossManova:\n    ModeledData:\n      session  n    f      q   names                                \n            1  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            2  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            3  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            4  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            5  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            6  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            7  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            8  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            9  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           10  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           11  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           12  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n      p = 572\n    Analysis 1:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 2:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 3:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 4:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 5:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 6:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 7:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 8:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 9:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 10:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 11:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 12:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 13:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 14:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 15:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 16:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 17:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 18:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 19:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 20:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 21:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 22:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 23:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 24:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 25:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 26:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 27:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    Analysis 28:\n      2 fold(s), 12 session(s)\n      CA = CB:  8 × 1, 1-dimensional\n      no permutations (besides neutral)\n    lambda: 1e-08\n\n\nThe results are contained in column 1 of the cell array Ds. We assemble them into a matrix, filling in the identical values in the lower triangular part and leaving zeros on the diagonal, and visualise the matrix as a heatmap:\n\n% assemble\nDsMatrix = zeros(nConds, nConds);\nDsMatrix(ind) = [Ds{:, 1}];\nDsMatrix = DsMatrix + DsMatrix .';\n% visualize\nfig = figure();\nfig.Position(3:4) = [750, 674];\nheatmap(conditions, conditions, DsMatrix, ...\n    FontName=get(0, 'defaultTextFontName'));\nylabel(gca().NodeChildren(2), 'D')",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/pairwise.html#comparison-with-original-analysis-results",
    "href": "tutorial-fmri-spm/pairwise.html#comparison-with-original-analysis-results",
    "title": "Pairwise Cross-validated MANOVA",
    "section": "Comparison with original analysis results",
    "text": "Comparison with original analysis results\nHaxby et al.’s main result (Table 1) was the identification accuracy for each of the eight categories averaged across classification pairs, and then averaged across six subjects. For ‘all ventral temporal object-selective cortex’, presumably corresponding to the region 1 used here (mask4_vt.nii), they reported the following accuracies (in percent):\n\nmeanAcc = [100, 100,  98,  90,  92,  92,  96, 100];\n\nOur corresponding result is the average pattern distinctness across the 7 pairwise contrasts each category was involved in:\n\nmeanD = sum(DsMatrix) / (nConds - 1)\n\nmeanD =\n  Columns 1 through 6\n      0.90465       1.0821      0.82983      0.53644      0.61424      0.65634\n  Columns 7 through 8\n      0.63137      0.86377\n\n\nPlotted against each other:\n\nfig = figure();\nfig.Position(3:4) = [750, 713];\nfor i = 1 : nConds\n    plot(meanAcc(i), meanD(i), '.', Color=colors(i), MarkerSize=20)\n    hold all\nend\nlegend(conditions, Interpreter=\"none\", Location=\"NorthWest\")\nxlim([89, 101])\nylim([0.45, 1.15])\nxlabel(\"mean accuracy / %\")\nylabel(\"mean pattern distinctness\")\n\n\n\n\n\n\n\n\n\n\nThe ranking is similar though not identical. Note that the results cannot be completely equivalent since our analysis is based on one subject, while the mean accuracy is additionally averaged across subjects.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Pairwise Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html",
    "href": "tutorial-fmri-spm/model.html",
    "title": "Model",
    "section": "",
    "text": "Matlab script\n\n\n\ndownload\n% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% BOLD data (contains realignment information)\nfnBOLD = fullfile(sub, 'bold.nii');\n% realigned BOLD data\nfnrBOLD = fullfile(sub, 'rbold.nii');\n% directory for model\nmodelDir = fullfile(sub, 'model');\n% file containing model\nfnSPM = fullfile(modelDir, 'SPM.mat');",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html#specify-the-model",
    "href": "tutorial-fmri-spm/model.html#specify-the-model",
    "title": "Model",
    "section": "Specify the model",
    "text": "Specify the model\nInstead of the approach of the paper to use a single design matrix across all sessions, we here follow the standard approach of SPM, and use session-wise design matrices. Each of them contains eight HRF-convoluted regressors corresponding to the stimulus presentations of the eight conditions, six motion regressors derived from the realignment parameters, and a constant regressor.\n\n% get realignment parameters for motion regressors\nV = spm_vol(fnBOLD);\nmat = cat(4, V.mat);\n\n% create directory\nmkdir(modelDir)\n\n% SPM module 'fMRI model specification'\nfmri_spec = struct;\nfmri_spec.dir = {modelDir};         % model directory\nfmri_spec.timing.units = 'secs';    % units for onsets and durations\nfmri_spec.timing.RT = TR;           % repetition time (interscan interval)\nfmri_spec.timing.fmri_t = 25;       % microtime resolution: 0.1 s\nfmri_spec.timing.fmri_t0 = 12;      % microtime onset: middle of scan\n% for each session\nfor si = 1 : nSessions\n    % indices of scans in 4d BOLD image corresponding to session\n    vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);\n    fmri_spec.sess(si).scans = arrayfun(@(i) ...\n        sprintf('%s,%d', ...                % SPM's &lt;filename&gt;,&lt;scan&gt; syntax\n            fullfile(pwd, fnrBOLD), i), ... % filename must include full path\n            vi, ...\n            'UniformOutput', false)';\n    % for each condition\n    for ci = 1 : nConds\n        % name, onsets, and durations\n        fmri_spec.sess(si).cond(ci).name = conditions{ci};\n        fmri_spec.sess(si).cond(ci).onset = onsets{si, ci};\n        fmri_spec.sess(si).cond(ci).duration = durations{si, ci};\n        fmri_spec.sess(si).cond(ci).tmod = 0;   % no time modulation\n        fmri_spec.sess(si).cond(ci).orth = 1;\n    end\n    fmri_spec.sess(si).multi = {''};        % no 'multiple conditions'\n    % motion regressors from realignment parameters\n    Q = nan(nVolsPerSession, 6);\n    for i = 1 : nVolsPerSession\n        qq = spm_imatrix(mat(:, :, vi(i)) / mat(:, :, vi(1)));\n        Q(i, :) = qq(1 : 6);\n    end\n    for mi = 1 : 6\n        fmri_spec.sess(si).regress(mi).name = sprintf('motion(%d)', mi);\n        fmri_spec.sess(si).regress(mi).val = Q(:, mi);\n    end\n    fmri_spec.sess(si).multi_reg = {''};    % no 'multiple regressors'\n    fmri_spec.sess(si).hpf = 128;           % high-pass cutoff time (def.)\nend\nfmri_spec.bases.hrf.derivs = [0 0]; % no HRF derivatives\nfmri_spec.volt = 1;                 % do not model interactions\nfmri_spec.global = 'None';          % no global intensity normalization\nfmri_spec.mthresh = 0.8;            % masking threshold (def.)\nfmri_spec.mask = {''};              % no explicit mask\nfmri_spec.cvi = 'AR(1)';            % model serial correlations as AR(1) (def.)\n% run module\nmatlabbatch = {};\nmatlabbatch{1}.spm.stats.fmri_spec = fmri_spec;\nspm_jobman('run', matlabbatch(1))\n\nInitialising batch system... done.\n\n\n------------------------------------------------------------------------\n18-Nov-2023 21:12:29 - Running job #1\n------------------------------------------------------------------------\n18-Nov-2023 21:12:30 - Running 'fMRI model specification'\n\nSPM12: spm_fMRI_design (v7739)                     21:12:30 - 18/11/2023\n========================================================================\nSaving fMRI design                      :               ...SPM.mat saved\n\nSPM12: spm_fmri_spm_ui (v7738)                     21:12:31 - 18/11/2023\n========================================================================\nMapping files                           :                        ...done\nCalculating globals                     :                        ...done\nSaving SPM configuration                :               ...SPM.mat saved\nSaving SPM configuration                :               ...SPM.mat saved\nCompleted                               :          21:12:43 - 18/11/2023\n18-Nov-2023 21:12:43 - Done    'fMRI model specification'\n18-Nov-2023 21:12:43 - Done",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html#visualize-the-model",
    "href": "tutorial-fmri-spm/model.html#visualize-the-model",
    "title": "Model",
    "section": "Visualize the model",
    "text": "Visualize the model\n\nload(fullfile(modelDir, 'SPM.mat'), 'SPM')\nfilenames = SPM.xY.P(:, numel(pwd) + 2 : end);\nfilenames = reshape(cellstr(filenames), size(SPM.xY.VY));\nspm_DesRep('DesMtx', SPM.xX, filenames, SPM.xsDes);",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/model.html#estimate-the-model",
    "href": "tutorial-fmri-spm/model.html#estimate-the-model",
    "title": "Model",
    "section": "Estimate the model",
    "text": "Estimate the model\n\n% SPM module 'fMRI model estimation'\nfmri_est = struct;\nfmri_est.spmmat = {fnSPM};          % path to `SPM.mat`\nfmri_est.write_residuals = 0;       % do not write residuals\nfmri_est.method.Classical = 1;      % frequentist statistical estimation\n% run module\nmatlabbatch = {};\nmatlabbatch{1}.spm.stats.fmri_est = fmri_est;\nspm_jobman('run', matlabbatch(1))\n\n\n\n------------------------------------------------------------------------\n18-Nov-2023 21:12:50 - Running job #1\n------------------------------------------------------------------------\n18-Nov-2023 21:12:50 - Running 'Model estimation'\n\nSPM12: spm_spm (v7738)                             21:12:50 - 18/11/2023\n========================================================================\n\nSPM12: spm_est_non_sphericity (v7577)              21:12:53 - 18/11/2023\n========================================================================\nChunk   2/2                             :                        ...done\nTemporal non-sphericity (27073 voxels)  :             ...ReML estimation\n  ReML Block 1                \n  ReML Iteration 1                      :        ...9.827664e+00 [+4.25]\n  ReML Iteration 2                      :        ...5.884532e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.599118e-02 [+4.75]\n  ReML Block 2                \n  ReML Iteration 1                      :        ...1.118494e+01 [+4.25]\n  ReML Iteration 2                      :        ...8.181662e-01 [+4.50]\n  ReML Iteration 3                      :        ...2.286568e-02 [+4.75]\n  ReML Block 3                \n  ReML Iteration 1                      :        ...6.901230e+00 [+4.25]\n  ReML Iteration 2                      :        ...1.429964e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.248735e-03 [+4.75]\n  ReML Block 4                \n  ReML Iteration 1                      :        ...9.365361e+00 [+4.25]\n  ReML Iteration 2                      :        ...3.411252e-01 [+4.50]\n  ReML Iteration 3                      :        ...5.701104e-03 [+4.75]\n  ReML Block 5                \n  ReML Iteration 1                      :        ...1.027357e+01 [+4.25]\n  ReML Iteration 2                      :        ...4.295659e-01 [+4.50]\n  ReML Iteration 3                      :        ...7.688102e-03 [+4.75]\n  ReML Block 6                \n  ReML Iteration 1                      :        ...1.323103e+01 [+4.25]\n  ReML Iteration 2                      :        ...3.478206e-01 [+4.50]\n  ReML Iteration 3                      :        ...6.419885e-03 [+4.75]\n  ReML Block 7                \n  ReML Iteration 1                      :        ...1.774148e+01 [+4.25]\n  ReML Iteration 2                      :        ...1.183276e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.092870e-03 [+4.75]\n  ReML Block 8                \n  ReML Iteration 1                      :        ...1.752418e+01 [+4.25]\n  ReML Iteration 2                      :        ...1.037713e-01 [+4.50]\n  ReML Iteration 3                      :        ...8.001813e-04 [+4.75]\n  ReML Block 9                \n  ReML Iteration 1                      :        ...2.328423e+01 [+4.25]\n  ReML Iteration 2                      :        ...8.247045e-01 [+4.50]\n  ReML Iteration 3                      :        ...1.707144e-02 [+4.75]\n  ReML Block 10               \n  ReML Iteration 1                      :        ...2.362216e+01 [+4.25]\n  ReML Iteration 2                      :        ...2.052704e-01 [+4.50]\n  ReML Iteration 3                      :        ...9.280063e-04 [+4.75]\n  ReML Block 11               \n  ReML Iteration 1                      :        ...7.029397e+00 [+4.25]\n  ReML Iteration 2                      :        ...4.771267e-03 [+4.50]\n  ReML Block 12               \n  ReML Iteration 1                      :        ...7.075062e+00 [+4.25]\n  ReML Iteration 2                      :        ...5.880034e-02 [+4.50]\n\nSPM12: spm_spm (v7738)                             21:12:58 - 18/11/2023\n========================================================================\nChunk   2/2                             :                        ...done\nSpatial non-sphericity (over scans)     :                        ...done\nSaving SPM.mat                          :                        ...done\nCompleted                               :          21:13:08 - 18/11/2023\nDone\n18-Nov-2023 21:13:08 - Done    'Model estimation'\n18-Nov-2023 21:13:08 - Done\n\n\n\nOur analyses only need the updates to the SPM.mat file made during estimation, not the parameter estimates themselves. We therefore delete the created beta_####.nii files.\n\nload(fnSPM, 'SPM');\nfor i = 1 : numel(SPM.Vbeta)\n    spm_unlink(fullfile(modelDir, SPM.Vbeta(i).fname))\nend",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Model"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/index.html",
    "href": "tutorial-fmri-spm/index.html",
    "title": "Tutorial: fMRI with SPM",
    "section": "",
    "text": "As an example for how to use the toolbox to analyze fMRI data, here we apply Cross-validated MANOVA as well as Cross-validated Cross-MANOVA to the data of subject 1 from Haxby et al. (2001).\nThe details of the experiment and analysis are presented in footnotes. From Footnote 18:\n\nStimuli were gray-scale images of faces, houses, cats, bottles, scissors, shoes, chairs, and nonsense patterns. The categories were chosen so that all stimuli from a given category would have the same base level name. […]\nTwelve time series were obtained in each subject. Each time series began and ended with 12 s of rest and contained eight stimulus blocks of 24-s duration, one for each category, separated by 12-s intervals of rest. Stimuli were presented for 500 ms with an interstimulus interval of 1500 ms. […]\nTo determine the patterns of response to each category on even-numbered and odd-numbered runs, we used a 16-regressor model—eight regressors to model the response to each category relative to rest on even runs and eight regressors to model the response to each category on odd runs with no regressor that contrasted all stimulus blocks to rest.\n\nFrom Footnote 19:\n\nAnalysis of the accuracy with which the category being viewed could be identified focused on comparisons between patterns of response for pairs of categories […]\nIf the within-category correlation (for example, response to category A on even and odd runs) was larger than the between-category correlation (correlation of the response to category A on even runs with the response to category B on odd runs), that comparison was counted as a correct identiﬁcation.\n\nThe main result of the paper is the identification accuracy for each category, determined in several different regions of interest and presented in Table 1.\nOur analysis is broken down into several steps in the following subpages:\n\n\n\n\n\n\n\n\n\n\n\n\nPreparation\n\n\nData are downloaded, preprocessed, and design information extracted\n\n\n\n\n\n\n\n\n\n\n\n\nModel\n\n\nA model for the data is set up and estimated in SPM\n\n\n\n\n\n\n\n\n\n\n\n\nCross-validated MANOVA\n\n\nPattern distinctness is computed in regions of interest and via searchlight\n\n\n\n\n\n\n\n\n\n\n\n\nPairwise Cross-validated MANOVA\n\n\nPattern distinctness is computed in a way approximating the original analysis\n\n\n\n\n\n\n\n\n\n\n\n\nCross-validated Cross-MANOVA\n\n\nPattern stability is computed in regions of interest and via searchlight\n\n\n\n\n\n\n\n\n\n\nNo matching items\n\nReferences\n\nHaxby, J. V., Gobbini, M. I., Furey, M. L., Ishai, A., Schouten, J. L., & Pietrini, P. (2001). Distributed and overlapping representations of faces and objects in ventral temporal cortex. Science, 293, 2425–2430. https://doi.org/10.1126/science.1063736",
    "crumbs": [
      "Tutorial: fMRI with SPM"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CvCrossManova Toolbox",
    "section": "",
    "text": "Warning\n\n\n\nThis project is under development.\n\n\nCvCrossManova is a toolbox for Matlab which implements the Cross-validated MANOVA and Cross-validated Cross-MANOVA algorithms.\nCross-validated MANOVA was introduced by Allefeld & Haynes (2014) as a method for multivariate pattern analysis (MVPA) in fMRI. Unlike most MVPA methods, it is not based on the accuracy of a classification algorithm, but estimates the multivariate variance explained by a contrast applied to a general linear model (GLM), called pattern distinctness D. Using the GLM has the advantage of a common basis with univariate fMRI analyses, resulting in an interpretable measure of effect size, and being applicable to designs where there are no classes. Other than standard GLM-based methods however, it uses cross-validation to obtain an unbiased estimator of that explained multivariate variance.\nA limitation of Cross-validated MANOVA was that it provided no analog of cross-classification, i.e. training a classifier on one pair of classes and testing it on another pair of classes, though the original paper pointed to the possibility to use interaction contrasts for a similar purpose. In recent papers, we used an adapted version of Cross-validated MANOVA which uses two different contrasts for ‘training’ and ‘validation’, called Cross-validated Cross-MANOVA, but it was published only in the methods sections of these papers. A forthcoming methodological paper will remedy that, and the CvCrossManova toolbox is the corresponding published implementation. Cross-validated Cross-MANOVA estimates the explained multivariate variance shared between two contrasts, called pattern stability D×.\nAn implementation of Cross-validated MANOVA was provided previously by the CvManova toolbox. Because Cross-validated MANOVA is a special case of Cross-validated Cross-MANOVA, the CvCrossManova toolbox implements both and is therefore an extended revision of the CvManova toolbox.\nThese pages document how to use the CvCrossManova toolbox to estimate both pattern distinctness and pattern stability, including examples of analysing fMRI data supported by SPM and other data (in this case EEG).\n\n\n\n\n\n\nInstallation\n\n\nHow to download and install the toolbox and its dependencies\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial: fMRI with SPM\n\n\nExample analysis of data of Haxby et al. (2001)\n\n\n\n\n\n\n\n\n\n\n\n\nTutorial: Other data\n\n\nExample analysis of data of Kappenman et al. (2021)\n\n\n\n\n\n\n\n\n\n\n\n\nAPI Reference documentation\n\n\nDetailed information about toolbox functions and classes\n\n\n\n\n\n\n\n\n\n\nNo matching items\n\n\n\nThe CvCrossManova toolbox is copyrighted © 2023 by Carsten Allefeld and released under the terms of the GNU General Public License, version 3 or later. Remi Gau, Polina Iamshchinina, and Thomas Christophel contributed to earlier versions of the code.\nThis documentation was created with Quarto using a slightly modified Cosmo Bootswatch theme. It is set in Source Sans 3 and Source Code Pro. Matlab code was executed using MKernel.\n\n\n\n\n\nReferences\n\nAllefeld, C., & Haynes, J.-D. (2014). Searchlight-based multi-voxel pattern analysis of fMRI by cross-validated MANOVA. NeuroImage, 89, 345–357. https://doi.org/10.1016/j.neuroimage.2013.11.043"
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "The CvCrossManova toolbox has been developed with Matlab R2023b, but should work with later and slightly earlier versions; the most recently introduced feature used by the code is from R2021a.\nThe core functionality does not depend on other toolboxes. However, functions which read data modeled in SPM12 (ccmRegion, ccmSearchlight, ModeledData.fromSPM) depend on it being installed. You can download SPM12 from the pages of the Functional Imaging Lab at UCL. The toolbox was developed using r7771, but other versions of SPM12 should work, too. It has not been tested with SPM8 or earlier.\nTo install the toolbox, download the file cvcrossmanova-v#.#.#.zip from the latest GitHub release. Unzip the file into a directory, and make sure that the created directory cvcrossmanova-v#.#.#/ is on the Matlab search path. If you install a newer version, make sure that the old version is no longer on the path.\nThe code for the toolbox as well as this documentation is maintained in a git repository on GitHub. If you need the latest not yet released version, clone the repository with\ngit clone https://github.com/allefeld/cvcrossmanova.git\nand copy the files in the toolbox/ subdirectory into a directory on the Matlab search path.\nIf you found a bug or have an idea for improvement, you can create an issue on the repository.",
    "crumbs": [
      "Installation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html",
    "href": "tutorial-fmri-spm/preparation.html",
    "title": "Preparation",
    "section": "",
    "text": "Matlab script\n\n\n\ndownload",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#download-and-unpack-data",
    "href": "tutorial-fmri-spm/preparation.html#download-and-unpack-data",
    "title": "Preparation",
    "section": "Download and unpack data",
    "text": "Download and unpack data\n\n% select subject\nsub = 'subj1';\n% start from scratch\n[~] = rmdir(sub, 's');\n\nThe data for the subject are downloaded from PyMVPA as a .tar.gz archive, and the archive is unpacked.\n\nfn = [sub '-2010.01.14.tar.gz'];\nurl = ['http://data.pymvpa.org/datasets/haxby2001/' fn];\nwebsave(fn, url);\nuntar(fn)\ndelete(fn)\n\nThe included NIfTI images are individually gzip-compressed and need to be uncompressed.\n\nfiles = dir(fullfile(sub, '*.nii.gz'));\nfor i = 1 : numel(files)\n    fprintf('uncompressing %s\\n', files(i).name)\n    gunzip(fullfile(sub, files(i).name))\n    delete(fullfile(sub, files(i).name))\nend\n\nuncompressing anat.nii.gz\nuncompressing bold.nii.gz\nuncompressing mask4_vt.nii.gz\nuncompressing mask8_face_vt.nii.gz\nuncompressing mask8_house_vt.nii.gz\nuncompressing mask8b_face_vt.nii.gz\nuncompressing mask8b_house_vt.nii.gz\n\n\nThe mask images are not documented in detail. Based on the filenames and the in-mask volume, we assume the following correspondence between regions listed in Table 1 of the paper and mask image files:\n\n\n\nmask4_vt.nii\n‘all ventral temporal object-selective cortex’\n\n\nmask8b_face_vt.nii\n‘region maximally responsive to faces’\n\n\nmask8b_house_vt.nii\n‘region maximally responsive to houses’\n\n\n\n\nfnBOLD = fullfile(sub, 'bold.nii');\nregions = {fullfile(sub, 'mask4_vt.nii'), ...\n           fullfile(sub, 'mask8b_face_vt.nii'), ...\n           fullfile(sub, 'mask8b_house_vt.nii')};",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#obtain-experimental-design-information",
    "href": "tutorial-fmri-spm/preparation.html#obtain-experimental-design-information",
    "title": "Preparation",
    "section": "Obtain experimental design information",
    "text": "Obtain experimental design information\nThe BOLD data are contained in a single 4-dimensional NIfTI file.\n\nN = nifti(fnBOLD);\nsize(N.dat)\ndiag(N.mat(1:3, 1:3)) .'\nTR = N.timing.tspace\n\nans =\n          40          64          64        1452\nans =\n         -3.5         3.75         3.75\nTR =\n          2.5\n\n\nThis file contains a timeseries of 1452 scans at at repetition time of 2.5 s, each of which has 40 × 64 × 64 voxels of size 3.5 × 3.75 × 3.75 mm.\nThere were 12 sessions, each of which consisted of 8 stimulus blocks of 24 s. There were rest periods of 12 s each at the beginning, end, and in between blocks. Each session therefore had a duration of (12 + 24) × 8 + 12 = 300 s, corresponding to 120 TRs (121 scans).\nInformation about the onsets and durations of stimuli in this subject are contained in a file labels.txt.\n\nlabels = readtable(fullfile(sub, 'labels.txt'), 'Delimiter', ' ');\nhead(labels)\n\n       labels       chunks\n    ____________    ______\n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'rest'    }      0   \n    {'scissors'}      0   \n    {'scissors'}      0   \n\n\n\ntail(labels)\n\n       labels       chunks\n    ____________    ______\n    {'scissors'}      11  \n    {'scissors'}      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n    {'rest'    }      11  \n\n\nIt has 1452 rows, corresponding to the scans of the BOLD data. The format is not documented, but it appears that the column labels contains the experimental condition (stimulus type), and the column chunk distinguishes the 12 sessions by an index from 0 to 11, each with 121 rows. In the order of the paper, the condition names are\n\nconditions = [\"face\", \"house\", \"cat\", \"bottle\", ...\n    \"scissors\", \"shoe\", \"chair\", \"scrambledpix\"];\n\nplus \"rest\" for the rest intervals. Stimulus blocks comprise 9 rows with rest intervals of 5 or 6 rows, which does not exactly correspond to the description above because the stimulus presentation length is incompatible with the TR.\nWe therefore use these data only to extract the condition index for each block, but recreate more precise stimulus timing information.\n\nnSessions = 12;\nnConds = numel(conditions);\nonsets = cell(nSessions, nConds);\ndurations = cell(nSessions, nConds);\n% for each session\nfor si = 1 : nSessions\n    % extract condition for each block (from its middle)\n    cond = labels.labels(labels.chunks == si - 1);\n    [~, condInd] = ismember(cond, conditions);\n    condInd = condInd(round((24 :(12 + 24): 300) / TR) + 1);\n    assert(isequal(sort(condInd).', 1:8))\n    % for each condition\n    for ci = 1 : nConds\n        % assemble stimulus onset and duration information in s\n        blockInd = find(condInd == ci);\n        blockStart = (blockInd - 1) * (12 + 24) + 12;\n        onsets{si, ci} = blockStart + (0 : 11) * (0.5 + 1.5);\n        durations{si, ci} = 0.5 * ones(1, 12);\n    end\nend\nnVolsPerSession = height(labels) / nSessions;\n\nVisualization of stimulus onsets in each session:\n\nfig = figure;\nfig.Position(3:4) = [750, 400];\ncolors = [\"#000000\", \"#ff9b00\", \"#a6ee00\", \"#00eea6\", ...\n    \"#009bff\", \"#a600ff\", \"#ff00a6\", \"#aaaaaa\"];\nfor ci = 1 : nConds\n    ons = [];\n    ses = [];\n    for si = 1 : nSessions\n        ons = [ons, onsets{si, ci}];\n        ses = [ses, si * ones(size(onsets{si, ci}))];\n    end\n    plot(ons, ses, '.', 'Color', colors(ci))\n    hold all\nend\nxlim([-1 , nVolsPerSession] * TR)\nylim([0.5, nSessions + 0.5])\nset(gca, 'YTick', 1 : nSessions)\nset(gca, 'YDir', 'reverse')\nylabel('session')\nxlabel('time / s')\nlegend(conditions, Location=\"eastoutside\")",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#realign-bold-data",
    "href": "tutorial-fmri-spm/preparation.html#realign-bold-data",
    "title": "Preparation",
    "section": "Realign BOLD data",
    "text": "Realign BOLD data\n\nfnrBOLD = fullfile(sub, 'rbold.nii');\nmatlabbatch = {};\nfor si = 1 : nSessions\n    vi = (si - 1) * nVolsPerSession + (1 : nVolsPerSession);\n    vn = arrayfun(@(i) sprintf('%s,%d', fnBOLD, i), ...\n        vi, 'UniformOutput', false);\n    matlabbatch{1}.spm.spatial.realign.estwrite.data{si} = vn';\nend\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.quality = 0.9;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.sep = 4;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.fwhm = 5;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.rtm = 1;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.interp = 2;\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.wrap = [0 0 0];\nmatlabbatch{1}.spm.spatial.realign.estwrite.eoptions.weight = '';\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.which = [2 1];\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.interp = 4;\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.wrap = [0 0 0];\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.mask = 1;\nmatlabbatch{1}.spm.spatial.realign.estwrite.roptions.prefix = 'r';\nspm_jobman('run', matlabbatch)\n\nInitialising batch system... done.\n\n\n------------------------------------------------------------------------\n18-Nov-2023 21:05:49 - Running job #1\n------------------------------------------------------------------------\n18-Nov-2023 21:05:49 - Running 'Realign: Estimate & Reslice'\n\nSPM12: spm_realign (v7141)                         21:05:49 - 18/11/2023\n========================================================================\nCompleted                               :          21:09:58 - 18/11/2023\n\nSPM12: spm_reslice (v7141)                         21:09:58 - 18/11/2023\n========================================================================\nCompleted                               :          21:11:58 - 18/11/2023\n18-Nov-2023 21:11:58 - Done    'Realign: Estimate & Reslice'\n18-Nov-2023 21:11:58 - Done",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/preparation.html#save-information",
    "href": "tutorial-fmri-spm/preparation.html#save-information",
    "title": "Preparation",
    "section": "Save information",
    "text": "Save information\n\nsave(fullfile(sub, 'info.mat'), 'regions', 'TR', 'nSessions', ...\n    'nVolsPerSession', 'conditions', 'nConds', 'onsets', 'durations', 'colors')",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html",
    "href": "tutorial-fmri-spm/cvmanova.html",
    "title": "Cross-validated MANOVA",
    "section": "",
    "text": "Matlab script\n\n\n\ndownload\n% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% directory with estimated model\nmodelDir = fullfile(sub, 'model');",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#define-contrasts",
    "href": "tutorial-fmri-spm/cvmanova.html#define-contrasts",
    "title": "Cross-validated MANOVA",
    "section": "Define contrasts",
    "text": "Define contrasts\nWe are looking at two effects:\n\nthe ‘effect of category’, i.e. quantifying how much patterns associated with the eight different stimulus categories differ from each other and\nthe ‘effect of category within inanimate object’, i.e. quantifying how much patterns associated with ‘bottle’, ‘scissors’, ‘shoe’, and ‘chair’ differ from each other.\n\nThe corresponding contrasts consist of 7 and 3 subcontrasts (columns), respectively, each of which targets the difference between two conditions.\n\nC_stimulus = ...\n    [  1  0  0  0  0  0  0      % face\n      -1  1  0  0  0  0  0      % house\n       0 -1  1  0  0  0  0      % cat\n       0  0 -1  1  0  0  0      % bottle\n       0  0  0 -1  1  0  0      % scissors\n       0  0  0  0 -1  1  0      % shoe\n       0  0  0  0  0 -1  1      % chair\n       0  0  0  0  0  0 -1 ];   % scrambledpix\nC_object_category = ...\n    [  0  0  0                  % face\n       0  0  0                  % house\n       0  0  0                  % cat\n       1  0  0                  % bottle\n      -1  1  0                  % scissors\n       0 -1  1                  % shoe\n       0  0 -1                  % chair\n       0  0  0 ];               % scrambledpix\n\nNote that though the subcontrasts only combine neighboring conditions, the null hypothesis defined by all of them together says that there is no difference in the patterns associated with any of the involved conditions. For example for C_object_category, the three subcontrasts state\n\npattern of ‘bottle’ = pattern of ‘scissors’,\npattern of ‘scissors’ = pattern of ‘shoe’, and\npattern of ‘shoe’ = pattern of ‘chair’.\n\nIf all three statements hold, that also implies that there is no difference e.g. between the pattern of ‘bottle’ and the pattern of ‘chair’. The result of cross-validated MANOVA, pattern distinctness D, estimates how much multivariate variance deviates from the null hypothesis encoded in a contrast.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#define-analyses",
    "href": "tutorial-fmri-spm/cvmanova.html#define-analyses",
    "title": "Cross-validated MANOVA",
    "section": "Define analyses",
    "text": "Define analyses\nAn analysis is represented by an object of class Analysis. It comprises two contrasts, for ‘training’ (A) and ‘validation’ (B), but for cross-validated MANOVA the two are identical. It also defines a validation scheme which for each fold specifies which sessions are used for ‘training’ and ‘validation’. Here we use standard leave-one-session-out cross-validation, but more complex schemes can be defined.\n\nanalysis_stimulus = Analysis.leaveOneSessionOut(nSessions, C_stimulus)\n\nanalysis_stimulus = \n  Analysis:\n    12 fold(s), 12 session(s)\n    CA = CB:  8 × 7, 7-dimensional\n    no permutations (besides neutral)\n\n\n\nanalysis_object_category = Analysis.leaveOneSessionOut( ...\n    nSessions, C_object_category)\n\nanalysis_object_category = \n  Analysis:\n    12 fold(s), 12 session(s)\n    CA = CB:  8 × 3, 3-dimensional\n    no permutations (besides neutral)\n\n\nBy default no permutations are performed, but that can be requested explicitly. We here limit the number of permutations to 100, though a larger number is recommended if available.\n\nrng(1837146515, 'twister')\nanalysis_object_category.addPermutations(maxPerms=100)\n\n2048 permutations possible\nrandomly selecting a subset of 100 permutations\n\n\nIf the requested number of permutations (parameter maxPerms, default 1000) is larger than or equal to the number of possible permutations, all possible permutations are performed; if not, a subset is chosen randomly. For reproducibility of analyses it is advisable to explicitly initialize Matlab’s random number generator with rng. The arguments used here were originally chosen based on the fields Seed and Type from running s = rng('shuffle') once.\nAs seen above, evaluating an Analysis object prints a brief summary. It can also be visualized using the method show:\n\nanalysis_object_category.show()\n\n\n\n\n\n\n\n\n\n\nBelow we need a cell array which contains all Analysis objects.\n\nanalyses = {analysis_stimulus, analysis_object_category};",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#run-analyses-on-regions-of-interest",
    "href": "tutorial-fmri-spm/cvmanova.html#run-analyses-on-regions-of-interest",
    "title": "Cross-validated MANOVA",
    "section": "Run analyses on regions of interest",
    "text": "Run analyses on regions of interest\nTo perform region-of-interest analyses, use the function ccmRegion. The output first reports on loading the data and then displays the involved objects1, including information on data, design matrices, and analyses.\n\n[Ds, ps] = ccmRegion(modelDir, regions, analyses);\n\n\nccmRegion\n\nloading data via subj1/model/SPM.mat\n  volume of 40 × 64 × 64 = 163840 voxels\n  27638 voxels within brain mask\n    572 voxels within brain mask in subj1/mask4_vt.nii\n    21 voxels within brain mask in subj1/mask8b_face_vt.nii\n    225 voxels within brain mask in subj1/mask8b_house_vt.nii\n  572 voxels within brain mask in all regions\n  reading images from subj1/rbold.nii,????\n  1452 of 1452 volumes loaded\n  whitening\n  high-pass-filtering\n\ncomputing Cross-validated (Cross-) MANOVA\n  CvCrossManova:\n    ModeledData:\n      session  n    f      q   names                                \n            1  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            2  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            3  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            4  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            5  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            6  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            7  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            8  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            9  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           10  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           11  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           12  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n      p = 572\n    Analysis 1:\n      12 fold(s), 12 session(s)\n      CA = CB:  8 × 7, 7-dimensional\n      no permutations (besides neutral)\n    Analysis 2:\n      12 fold(s), 12 session(s)\n      CA = CB:  8 × 3, 3-dimensional\n      100 permutations (including neutral)\n    lambda: 1e-08\n\n\nThe result ps is an array with the number of voxels in each region.\n\nps\n\nps =\n   572    21   225\n\n\nThe result Ds is a cell array with one row for each analysis, and one column for each region. For the first analysis each cell contains a scalar, which is the estimated value of D.\n\nDs(1, :)\n\nans =\n  1x3 cell array\n    {[5.3228]}    {[0.36733]}    {[2.4592]}\n\n\nFor the second analysis each cell contains an array with 100 elements, corresponding to the 100 permutations we requested. The first value is the actual estimated value of D, the others are permutation values.\n\nDs(2, :)\n\nans =\n  1x3 cell array\n    {1x100 double}    {1x100 double}    {1x100 double}\n\n\nBased on this, we can calculate a p-value for the null hypothesis ‘no effect of category within inanimate object’, in each region.\n\nfor i = 1 : numel(regions)\n    D = Ds{2, i};\n    pval = mean(D &gt;= D(1));\n    fprintf('%-25s  D = %.4f  p = %g\\n', regions{i}, D(1), pval)\nend\n\nsubj1/mask4_vt.nii         D = 1.0309  p = 0.01\nsubj1/mask8b_face_vt.nii   D = 0.0220  p = 0.05\nsubj1/mask8b_house_vt.nii  D = 0.3718  p = 0.01\n\n\nThe null hypothesis can be rejected in all three regions.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#run-analyses-with-searchlight",
    "href": "tutorial-fmri-spm/cvmanova.html#run-analyses-with-searchlight",
    "title": "Cross-validated MANOVA",
    "section": "Run analyses with searchlight",
    "text": "Run analyses with searchlight\nTo perform searchlight analyses, use the function ccmSearchlight. As before, the output first reports on loading the data and then displays the involved objects2, including information on data, design matrices, and analyses.\n\nslRadius = 3;\nccmSearchlight(modelDir, slRadius, analyses)\n\n\nccmSearchlight\n\nloading data via subj1/model/SPM.mat\n  volume of 40 × 64 × 64 = 163840 voxels\n  27638 voxels within brain mask\n  no region masks\n  reading images from subj1/rbold.nii,????\n  1452 of 1452 volumes loaded\n  whitening\n  high-pass-filtering\n\ncomputing Cross-validated (Cross-) MANOVA\n  CvCrossManova:\n    ModeledData:\n      session  n    f      q   names                                \n            1  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            2  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            3  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            4  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            5  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            6  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            7  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            8  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n            9  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           10  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           11  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n           12  121  102.0  15  face*bf(1), house*bf(1), cat*bf(1), …\n      p = 27638\n    Analysis 1:\n      12 fold(s), 12 session(s)\n      CA = CB:  8 × 7, 7-dimensional\n      no permutations (besides neutral)\n    Analysis 2:\n      12 fold(s), 12 session(s)\n      CA = CB:  8 × 3, 3-dimensional\n      100 permutations (including neutral)\n    lambda: 1e-08\n  running searchlight of radius 3 (123 voxels)\n  intermediate results are saved to\n      subj1/model/ccmSearchlightCheckpointC5455E411A34A2718B687FA5966503B2.mat\n    42.3 min  27638 voxels  100.0 %\n\n\nResults are written to files in the model directory. ccmSearchlightParams.mat is a record of the analysis parameters and VPSL.nii is an image file where each voxel contains the number of voxels of the searchlight centered on it.\n\ndir(modelDir)\n\n\n.                         spmD_A0002_P0029.nii      spmD_A0002_P0066.nii      \n..                        spmD_A0002_P0030.nii      spmD_A0002_P0067.nii      \nRPV.nii                   spmD_A0002_P0031.nii      spmD_A0002_P0068.nii      \nResMS.nii                 spmD_A0002_P0032.nii      spmD_A0002_P0069.nii      \nSPM.mat                   spmD_A0002_P0033.nii      spmD_A0002_P0070.nii      \nVPSL.nii                  spmD_A0002_P0034.nii      spmD_A0002_P0071.nii      \nccmSearchlightParams.mat  spmD_A0002_P0035.nii      spmD_A0002_P0072.nii      \nmask.nii                  spmD_A0002_P0036.nii      spmD_A0002_P0073.nii      \nspmD_A0001_P0001.nii      spmD_A0002_P0037.nii      spmD_A0002_P0074.nii      \nspmD_A0002_P0001.nii      spmD_A0002_P0038.nii      spmD_A0002_P0075.nii      \nspmD_A0002_P0002.nii      spmD_A0002_P0039.nii      spmD_A0002_P0076.nii      \nspmD_A0002_P0003.nii      spmD_A0002_P0040.nii      spmD_A0002_P0077.nii      \nspmD_A0002_P0004.nii      spmD_A0002_P0041.nii      spmD_A0002_P0078.nii      \nspmD_A0002_P0005.nii      spmD_A0002_P0042.nii      spmD_A0002_P0079.nii      \nspmD_A0002_P0006.nii      spmD_A0002_P0043.nii      spmD_A0002_P0080.nii      \nspmD_A0002_P0007.nii      spmD_A0002_P0044.nii      spmD_A0002_P0081.nii      \nspmD_A0002_P0008.nii      spmD_A0002_P0045.nii      spmD_A0002_P0082.nii      \nspmD_A0002_P0009.nii      spmD_A0002_P0046.nii      spmD_A0002_P0083.nii      \nspmD_A0002_P0010.nii      spmD_A0002_P0047.nii      spmD_A0002_P0084.nii      \nspmD_A0002_P0011.nii      spmD_A0002_P0048.nii      spmD_A0002_P0085.nii      \nspmD_A0002_P0012.nii      spmD_A0002_P0049.nii      spmD_A0002_P0086.nii      \nspmD_A0002_P0013.nii      spmD_A0002_P0050.nii      spmD_A0002_P0087.nii      \nspmD_A0002_P0014.nii      spmD_A0002_P0051.nii      spmD_A0002_P0088.nii      \nspmD_A0002_P0015.nii      spmD_A0002_P0052.nii      spmD_A0002_P0089.nii      \nspmD_A0002_P0016.nii      spmD_A0002_P0053.nii      spmD_A0002_P0090.nii      \nspmD_A0002_P0017.nii      spmD_A0002_P0054.nii      spmD_A0002_P0091.nii      \nspmD_A0002_P0018.nii      spmD_A0002_P0055.nii      spmD_A0002_P0092.nii      \nspmD_A0002_P0019.nii      spmD_A0002_P0056.nii      spmD_A0002_P0093.nii      \nspmD_A0002_P0020.nii      spmD_A0002_P0057.nii      spmD_A0002_P0094.nii      \nspmD_A0002_P0021.nii      spmD_A0002_P0058.nii      spmD_A0002_P0095.nii      \nspmD_A0002_P0022.nii      spmD_A0002_P0059.nii      spmD_A0002_P0096.nii      \nspmD_A0002_P0023.nii      spmD_A0002_P0060.nii      spmD_A0002_P0097.nii      \nspmD_A0002_P0024.nii      spmD_A0002_P0061.nii      spmD_A0002_P0098.nii      \nspmD_A0002_P0025.nii      spmD_A0002_P0062.nii      spmD_A0002_P0099.nii      \nspmD_A0002_P0026.nii      spmD_A0002_P0063.nii      spmD_A0002_P0100.nii      \nspmD_A0002_P0027.nii      spmD_A0002_P0064.nii      \nspmD_A0002_P0028.nii      spmD_A0002_P0065.nii      \n\n\n\nFiles with names of the form spmD_A####_P####.nii are images of pattern distinctness, i.e each voxel contains the estimated value of D from the voxels of the searchlight centered on it. The digits #### after A identify the analysis, and the digits after P the permutation (if no permutations were requested, only P0001 for the neutral permutation).\nWe visualize sagittal slices of spmD_A0001_P0001.nii, i.e. the actual pattern distinctness from the first analysis.\n\n% load data\n[D, XYZ] = spm_read_vols(spm_vol(fullfile(modelDir, 'spmD_A0001_P0001.nii')));\n% plot data\nfig = figure();\n% color map: parula, but black for NaN\ncm = parula();\ncm(1, :) = 0;\ncolormap(cm)\n% color limits from data\ncl = [min(D(:)), max(D(:))];\n% sagittal slices\nfig.Position(3:4) = [750, 1200];\ntiledlayout(8, 5, Padding=\"tight\", TileSpacing=\"tight\")\nfor i = 3 : 39\n    nexttile\n    slice = squeeze(D(i, :, :)) .'; \n    imagesc(slice)\n    clim(cl)\n    axis off image xy\nend\ncb = colorbar(Location='layout');\ncb.Layout.Tile = 40;\ncb.Label.String = 'D̂';\ncb.TickDirection = 'out';\n\n\n\n\n\n\n\n\n\n\nThe largest values of D seem to be attained bilaterally in ventral temporal cortex, presumably the fusiform gyrus. Constrained (approximately) to the right and left hemispheres, the maximal values are:\n\nx = reshape(XYZ(1, :), size(D));\nDright = D .* (x &gt; 0);\nmaxDright = max(Dright(:))\nx = reshape(XYZ(1, :), size(D));\nDleft = D .* (x &lt; 0);\nmaxDleft = max(Dleft(:))\n\nmaxDright =\n       2.1622\nmaxDleft =\n       2.1156",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvmanova.html#interpretation-of-pattern-distinctness",
    "href": "tutorial-fmri-spm/cvmanova.html#interpretation-of-pattern-distinctness",
    "title": "Cross-validated MANOVA",
    "section": "Interpretation of pattern distinctness",
    "text": "Interpretation of pattern distinctness\nThe method of Cross-validated MANOVA estimates pattern distinctness D, which is defined as the amount of multivariate variance of the data explained by the effect encoded in the contrast, in units of the multivariate error variance. As such, D is a number larger or equal to zero, but without upper limit.\nIn the region-of-interest analyses above, we found a maximum value of D = 5.3228 for analysis 1 in region 1. This value is quite large, but it has to be interpreted relative to the contrast, which targeted the very broad ‘effect of category’ for both visually and semantically very different categories. Moreover, D accumulates across voxels (not exactly additively, but depending on the error correlation between voxels), and therefore tends to be larger for larger sets of voxels. In this case, region 1 (‘all ventral temporal object-selective cortex’) included 572 voxels. By comparison, the same analysis resulted in D = 0.36733 in region 2 (‘region maximally responsive to faces’), which at 21 voxels is much smaller, and the searchlight of 123 voxels resulted in a maximum D of 2.1622.\nGiven that D is nonnegative, it may be surprising that the color bar for the slices from the searchlight analysis starts below zero, and indeed for analysis 1 D attained values from −0.1357 to 2.1622. The explanation is that the method can only provide a statistical estimate of D, more precisely denoted D̂. The estimator is designed to be unbiased, which means the estimates can be both larger and smaller than the actual value, and therefore an estimate can be negative if the actual value is close to zero. Such values should be disregarded since they can never be significantly different from zero.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvcrossmanova.html",
    "href": "tutorial-fmri-spm/cvcrossmanova.html",
    "title": "Cross-validated Cross-MANOVA",
    "section": "",
    "text": "Intro",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated Cross-MANOVA"
    ]
  },
  {
    "objectID": "tutorial-fmri-spm/cvcrossmanova.html#heading",
    "href": "tutorial-fmri-spm/cvcrossmanova.html#heading",
    "title": "Cross-validated Cross-MANOVA",
    "section": "Heading",
    "text": "Heading\nThis is an introductory text which explains all the very important things that are going to be done in this section.\n\n% select subject\nsub = 'subj1';\n% load information\nload(fullfile(sub, 'info.mat'))\n% directory with estimated model\nmodelDir = fullfile(sub, 'model');\n\n\n8 contrasts between animate (“face”, “cat”) and inanimate objects (“bottle”, “scissors”, “shoe”, “chair”). Cross-MANOVA for all pairs of contrasts.",
    "crumbs": [
      "Tutorial: fMRI with SPM",
      "Cross-validated Cross-MANOVA"
    ]
  },
  {
    "objectID": "tutorial-other/preparation.html",
    "href": "tutorial-other/preparation.html",
    "title": "Preparation",
    "section": "",
    "text": "Matlab script\n\n\n\ndownload",
    "crumbs": [
      "Tutorial: Other data",
      "Preparation"
    ]
  },
  {
    "objectID": "tutorial-other/preparation.html#download-and-load-data",
    "href": "tutorial-other/preparation.html#download-and-load-data",
    "title": "Preparation",
    "section": "Download and load data",
    "text": "Download and load data\n\n% select subject\nsub = 'subj1';\n% start from scratch\n[~] = rmdir(sub, 's');\n% URL for `1_P3_shifted_ds_reref_ucbip_hpfilt_ica_corr_cbip_elist_bins_epoch.set`\nsetURL = 'https://osf.io/download/d8yv4/';\n% URL for `1_P3_shifted_ds_reref_ucbip_hpfilt_ica_corr_cbip_elist_bins_epoch.fdt`\nfdtURL = 'https://osf.io/download/h4dtr/';",
    "crumbs": [
      "Tutorial: Other data",
      "Preparation"
    ]
  }
]